---
title: "WGCNA Hypothalamic Pituitary Gonadal Axis"
subtitle: "For manuscript: Neurogenomic landscape of male cooperative behavior in a wild bird "
date: Last Knit "`r Sys.Date()`"
author: "Last Substantive Change December 2023"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE, fig.align="center", comment=FALSE)
```

```{r libraries}
library(WGCNA)
library(flashClust)
library(plyr)
library(DESeq2)
library(PCAtools)
library(pheatmap)
library(kableExtra)
library(ggpubr)
library(clusterProfiler)
library(rrvgo)
enableWGCNAThreads()
options(stringsAsFactors = FALSE)

source("config.R")
```

```{r data}
key<- read.csv("../data_filtered/data_key_Parsed_ReplicatesRemoved.csv")
behav<- read.csv("../data_unfiltered/PIPFIL_T_and_behav_data.csv")
rownames(key)<- key$X

key$Color_ID<- sub("/","", key$Color_ID)
key<- plyr::rename(key, replace=c("Color_ID"="colorID"))
behav$status<- plyr::revalue(behav$status, c("floa"="floater", "terr"="territorial"))
key_behav<- merge(key, behav, by="colorID")
key_behav<- key_behav[!is.na(key_behav$last_behav),]


key_behav<- key_behav[order(key_behav$X),]

#create a data.frame with all of the observations. 
not_in_behav<- key[!key$X %in% key_behav$X,]
cols_not_key<- colnames(key_behav)[!colnames(key_behav) %in% colnames(key)]
cols_not_key_df<- data.frame(matrix(NA, nrow = nrow(not_in_behav), ncol = length(cols_not_key)))
colnames(cols_not_key_df)<- cols_not_key
not_in_behav<- cbind(not_in_behav, cols_not_key_df)

key_behav<- rbind(key_behav, not_in_behav)



data<- read.csv("../data_filtered/data_RawCounts_all_ReplicatesRemoved_antisense_V2.csv")
rownames(data)<- data$X
data$X<- NULL


```

```{r gene annot}
genes_key<- read.csv("../GO_annotations/Maggies_annotations_modifiedR.csv")
genes_key<- plyr::rename(genes_key, replace=c("GeneID"="gene"))
data_genes<- data.frame(gene=rownames(data))
genes_key<- merge(data_genes, genes_key, by="gene", all.x=TRUE)
#genes_key<- genes_key[which(grepl("LOC[0-9]+",genes_key$gene)),]

genes_key$display_gene_ID<- ifelse(grepl("LOC[0-9]+", genes_key$gene) & !grepl("LOC[0-9]+",genes_key$best_anno), paste0(genes_key$gene," (",genes_key$best_anno,")"), as.character(genes_key$gene))
genes_key<- genes_key[,c("gene","best_anno","display_gene_ID")]

  
  

go_terms<- read.csv("../GO_annotations/pfil_GO_key_raw.csv")
go_terms<- plyr::rename(go_terms, replace=c("GeneID"="gene"))
go2gene_bp<- go_terms[which(go_terms$Aspect=="P"),c("GO_ID", "gene")]
go2gene_mf<- go_terms[which(go_terms$Aspect=="F"),c("GO_ID", "gene")]
go_obo<- read.csv("../GO_annotations/ontology_obo_out.csv")
go_obo<- plyr::rename(go_obo, replace=c("id"="GO_ID"))
go2name_bp<- go_obo[which(go_obo$namespace=="biological_process"),c("GO_ID", "name")]
go2name_mf<- go_obo[which(go_obo$namespace=="molecular_function"),c("GO_ID", "name")]

```

# Subsetting & Filtering

```{r}
#identified as a consistent outlier
outliers=c("PFT2_POM_run1")
key_brain<- key_behav[which(key_behav$Tissue=="PIT" | key_behav$Tissue=="GON" | key_behav$Tissue=="POM" | key_behav$Tissue=="AH" | key_behav$Tissue=="PVN" | key_behav$Tissue=="VMH"),]
key_brain<- key_brain[!key_brain$X %in% outliers,]
key_brain<- key_brain[key_brain$Batch!="pilot",]
rownames(key_brain)<- key_brain$X

#
data<- data[, colnames(data) %in% key_brain$X]
###filter out lowly expressed genes
#
##remove genes with less than 5 reads
data$avg_count<- apply(data, 1, mean)
data<- data[data$avg_count>20,]
data$avg_count<-NULL
all.equal(colnames(data),rownames(key_brain))


dd<- DESeqDataSetFromMatrix(countData=data, colData=key_brain, design= ~ Tissue)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]

vsd_data<- getVarianceStabilizedData(dd)

p <- pca(vsd_data, metadata = key_brain)
biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", title="PCA Hypothalamic-Pituitary-Gonad tissues")
pairsplot(p, colby="Tissue", triangle = FALSE, shape="Batch")
eigencorplot(p, metavars = c("Batch","Year", "Status","Tissue"))
```

# Connectivity Test for Outliers

```{r}
wgcnadata<- as.data.frame(t(vsd_data))

gsg = goodSamplesGenes(wgcnadata, verbose = 3)
gsg$allOK


traits<- key_brain[, c("Batch",  "Year")]
traits$pilot<- as.numeric(ifelse(traits$Batch=="pilot",1,0))
traits$Run1<- as.numeric(ifelse(traits$Batch=="run1",1,0))
traits$Run2<- as.numeric(ifelse(traits$Batch=="run2",1,0))
traits$yr2015<- as.numeric(ifelse(traits$Year=="2015",1,0))
traits$yr2017<- as.numeric(ifelse(traits$Year=="2017",1,0))
traits$yr2018<- as.numeric(ifelse(traits$Year=="2018",1,0))

traits<- traits[,-(1:2)] 




A=adjacency(t(wgcnadata),type="signed")
#-----Calculate whole network connectivity
k=as.numeric(apply(A,2,sum))-1
#-----Standardized connectivity
Z.k=scale(k)
thresholdZ.k=-2.5 
outlierColor=ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
#-----Convert traits to colors
traitColors=data.frame(numbers2colors(traits,signed=FALSE))
dimnames(traitColors)[[2]]=paste(names(traits))
datColors=data.frame(outlier=outlierColor,traitColors)

#-----Plot the sample dendrogram
plotDendroAndColors(sampleTree,groupLabels=names(datColors),
                    colors=datColors,main="Sample dendrogram and trait heatmap")
```

No outliers

# Effect of Batch Correction

```{r batch correction}
mat<- limma::removeBatchEffect(vsd_data, key_brain$Batch)
p <- pca(mat, metadata = key_brain)
biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", title="PCA removeBatchEffect(Batch)")
eigencorplot(p, metavars = c("Batch","Year", "Status"))

```

Again this seems to make the differences between batches even larger... 

# Soft Threshold

```{r soft threshold, echo=TRUE, message=TRUE, comment=TRUE,warning=TRUE}
datExpr0<- as.data.frame(t(vsd_data))
#write.csv(datExpr0, file="../WGCNA_results/HPG/HPG_vsd.csv")
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK


powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")




par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=22
```

Seems like there is no strong effect on Scale Free Topology The soft-threshold power I have selected here is `r softPower`, after which there is little improvement in the Scale free topology fit. 

## Adjacency Matrix and TOM Matrix

```{r adjacency matrix, eval=FALSE, echo=TRUE}

softPower=22

#datExpr0<- read.csv("wholebrain_vsd_nobatchrm.csv")
#rownames(datExpr0)<- datExpr0$X
#datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMType="signed")
#dissTOM<- 1-TOM

save(adjacency, TOM, file="../WGCNA_results/HPG/HPG_network.RData")
```


<br>

# Identify co-expression modules

The first step is to identify modules of genes with similar gene expression. Basically, the tool creates a hierarchical clustering of the topological dissimilarity between genes.



```{r calculate modules, echo=TRUE, message=FALSE}



load("../WGCNA_results/HPG/HPG_network.RData")
dissTOM<- 1-TOM

geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")
```


Now we try to merge some of these modules that are particularly similar in expression based on a similarity threshold.


```{r, echo=TRUE}
#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


#plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.20 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
#abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs

```

<br>

## Module-trait correlation

Correlate the eigenvector of each of the `r ncol(MEs)` co-expression modules with brain regions, individual and batch, as well as our interest variables (mean testosterone, status, and social network strength) 

```{r trait correlation, echo=TRUE, fig.width=20, fig.height=12}
datTraits<- key_brain
all.equal(rownames(datExpr0), rownames(datTraits))

datTraits$Batch<-as.numeric(as.factor(datTraits$Batch))
datTraits$Year<- as.numeric(as.factor(datTraits$Year))
datTraits$POM<- ifelse(grepl("POM", datTraits$sampleID), 1,0)
datTraits$VMH<- ifelse(grepl("VMH", datTraits$sampleID), 1,0)
datTraits$AH<- ifelse(grepl("AH", datTraits$sampleID), 1,0)
datTraits$PVN<- ifelse(grepl("PVN", datTraits$sampleID), 1,0)
datTraits$GON<- ifelse(grepl("GON", datTraits$sampleID), 1,0)
datTraits$PIT<- ifelse(grepl("PIT", datTraits$sampleID), 1,0)
datTraits$Bird<- as.numeric(as.factor(datTraits$sampleID))

datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("Bird","Batch","Year","Status2", "mean_T","strength.all_study","VMH","AH","PVN","POM","GON","PIT"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"



#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6,10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in HPG"))
```

<br>

```{r}
knitr::kable(table(moduleColors), caption = paste("Number of genes per co-expression module")) %>% kable_styling()
```

See the data portion of this repository to see the the module membership and gene-significance results. 

```{r module memberships, echo=TRUE}
folder="../WGCNA_results/HPG/"
test="HPG"
datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <- merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste0(folder,test,"_results_ModuleMembership.csv"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste0(folder,test,"_results_ModuleMembership_P-value.csv"), row.names = FALSE)


#### gene-significance with traits of interest.
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")

folder="../WGCNA_results/HPG/"
test="HPG"
write.csv(GS, file=paste0(folder,test,"_results_GeneSignificance.csv"), row.names = FALSE)
```

<br>

## Intermodule correlations

Given the network type used, all genes in a module can only go in the same direction. This means that another module may represent genes that are downregulated by the upregulation of genes in another module (or vice-versa).

```{r intermodule correlations, fig.width=10, fig.height=10, echo=TRUE}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main="module eigengene correlation in HPG", legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```



```{r, eval=FALSE}
GO_WGCNA(color, "cyan",go2name_mf, go2gene_mf)
go_plot_result


```



## GO for modules

```{r}
for(m in unique(color$moduleColor)){
  whichModule=m
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("TOP enriched GO BP terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()

write.csv(ego@result, file=paste("../WGCNA_results/HPG/",whichModule, "GO_BP.csv", sep="_"))
}

```


# Module Connectivity


```{r terr adj}
#subset the territorial
terr_key<- key_brain[which(key_brain$Status=="territorial"),]


#subset the expression data to only include the territorial data

terr_dat<- datExpr0[rownames(datExpr0) %in% rownames(terr_key),]
#terr_dat<- terr_dat[,order(colnames(terr_dat))]


gsg = goodSamplesGenes(terr_dat, verbose = 3)
gsg$allOK

powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(terr_dat, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=22

#terr_adj<- adjacency<- adjacency(terr_dat, power = softPower, type="signed")
#save(terr_adj, file="../WGCNA_results/HPG/terr_adj.RData")

#TOM_terr<- TOMsimilarity(terr_adj, TOMType="signed")
#save(TOM_terr,file="../WGCNA_results/HPG/terr_TOM.RData")
```

```{r flo adj}

#subset the territorial
flo_key<- key_brain[which(key_brain$Status=="floater"),]


#subset the expression data to only include the floater data

flo_dat<- datExpr0[rownames(datExpr0) %in% rownames(flo_key),]
#flo_dat<- flo_dat[,order(colnames(flo_dat))]


gsg = goodSamplesGenes(flo_dat, verbose = 3)
gsg$allOK

powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(flo_dat, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=22


#flo_adj<- adjacency(flo_dat, power = softPower, type="signed")
#save(flo_adj, file="../WGCNA_results/HPG/flo_adj.RData")

#TOM_flo<- TOMsimilarity(flo_adj, TOMType="signed")
#save(TOM_flo,file="../WGCNA_results/HPG/flo_TOM.RData")
```


```{r connectivity}
#rm(list=c(adjacency,TOM,dissTOM))
load("../WGCNA_results/HPG/flo_adj.RData")
load("../WGCNA_results/HPG/terr_adj.RData")
color<-read.csv("../WGCNA_results/HPG/HPG_results_ModuleMembership.csv")
color<- color[match(colnames(terr_dat),color$gene,),]
all.equal(color$gene, colnames(terr_dat))
all.equal(color$gene, colnames(flo_dat))

#modcon<- intramodularConnectivity(adjacency, color$moduleColor)
#modcon$gene<- rownames(modcon)
#modcon<- merge(modcon, color, by="gene")
#modcon$Status<- "total_dataset"

#modcon_flo<- intramodularConnectivity.fromExpr(flo_dat, color$moduleColor, networkType = "signed", power=26)
modcon_flo<- intramodularConnectivity(flo_adj, color$moduleColor)
modcon_flo$gene<- rownames(modcon_flo)
modcon_flo$Status<- "floater"

#modcon_terr<- intramodularConnectivity.fromExpr(terr_dat, color$moduleColor, networkType = "signed", power =24)
modcon_terr<- intramodularConnectivity(terr_adj, color$moduleColor)
modcon_terr$gene<- rownames(modcon_terr)
modcon_terr$Status<- "territorial"

modcon_status<- rbind(modcon_terr,modcon_flo)
modcon_status<- merge(modcon_status, color,by="gene")

#modcon_third<- rbind(modcon_status,modcon)

#ggplot(modcon_third[modcon_third$moduleColor=="navajowhite2",], aes(x=Status,y=kTotal)) + geom_jitter(colour="grey80", width=0.3) + geom_violin(fill=NA, outlier.colour = NA) + peri_theme


```

```{r k plots}
library(reshape2)
means_stats<- list()
diffs<- list()
plots_total<- list()
plots_IM<- list()
plots_cor<- list()
cor_out<- list()

mwus_total<- list()
mwus_IM<- list()

pvalues_total<-  vector(mode="numeric")
pvalues_IM<-  vector(mode="numeric")
for(i in unique(color$moduleColor)){
  #i="darkturquoise"
  mod<- modcon_status[modcon_status$moduleColor==i,]
  
  #conduct mann-whitney u-test
  mwu<- wilcox.test(mod$kTotal[mod$Status=="territorial"],mod$kTotal[mod$Status=="floater"])
  mwus_total[[i]]<- mwu
  pvalues_total[i]<- mwu$p.value
  
   #conduct mann-whitney u-test kwithin
  mwu<- wilcox.test(mod$kWithin[mod$Status=="territorial"],mod$kWithin[mod$Status=="floater"])
  mwus_IM[[i]]<- mwu
  pvalues_IM[i]<- mwu$p.value

}


q_total<- p.adjust(pvalues_total, method="BH")
q_IM<- p.adjust(pvalues_IM, method="BH")

for(i in unique(color$moduleColor)){
    mod<- modcon_status[modcon_status$moduleColor==i,]
    mod2<- mod %>% group_by(Status) %>% summarise(means=mean(kTotal),medians=median(kTotal))
  mod2$module=i
  means_stats[[i]]<- mod2
  diffs[[i]]<- data.frame(module=i,mean_diff=mod2$means[2]-mod2$means[1],median_diff=mod2$medians[2]-mod2$medians[1])
  
  #kTotal Plot
  p<- ggplot() + geom_violin(data=mod,aes(x=Status,y=kTotal),fill=i) + geom_point(data=mod2, aes(x=Status, y=means), pch=21, fill="white") +geom_point(data=mod2, aes(x=Status, y=medians), pch=25, fill="white")
  p<- p + peri_figure_supp
  p<- p + labs(title=i, subtitle=paste0("diff. median connectivity (kTotal) ",signif(mod2$medians[2]-mod2$medians[1],2), "\nW=",mwus_total[[i]]$statistic,", p=",signif(mwus_total[[i]]$p.value,2),", q=",signif(q_total[i],2)))
  plots_total[[i]]<- p
  
   #kWithinPlot
  
   mod2<- mod %>% group_by(Status) %>% summarise(means=mean(kWithin),medians=median(kWithin))
   
   q<- ggplot() + geom_violin(data=mod,aes(x=Status,y=kWithin),fill=i) + geom_point(data=mod2, aes(x=Status, y=means), pch=21, fill="white") +geom_point(data=mod2, aes(x=Status, y=medians), pch=25, fill="white")
  q<- q + peri_figure_supp
  q<- q + labs(title=i, subtitle=paste0("diff. median connectivity (kWithin) ",signif(mod2$medians[2]-mod2$medians[1],2), "\nW=",mwus_IM[[i]]$statistic,", p=",signif(mwus_IM[[i]]$p.value,2),", q=",signif(q_IM[i],2)))
  plots_IM[[i]]<- q

  mod3<- dcast(mod,gene + moduleColor ~ Status, value.var = "kTotal")
  m<- lm(floater ~ territorial, data=mod3)
  rsq<- round(summary(m)$r.squared,2)
  mod3$residuals<- residuals(m)
  
    c<- ggplot(mod3, aes(x=territorial, y=floater)) + geom_point(fill=i,pch=21, size=2) + geom_smooth(method="lm", alpha=0.15, colour="black",fill="black") + peri_figure_supp + labs(title=i,subtitle=substitute(paste("R"^{2},"=",a),list(a=rsq)),x="Territorial Connectivity (kTotal)",y="Floater Connectivity (kTotal)")
  plots_cor[[i]]<- c  
  cor_out[[i]]<- mod3
  
}

#make plots
g<- ggarrange(plotlist=plots_total)
g
ggsave(filename="../WGCNA_results/HPG/figure_kTotal_all.png",g, height=210,width=210, units="mm",bg="white", device="png")
ggsave(filename="../WGCNA_results/HPG/figure_kTotal_all.pdf",g, height=210,width=210, units="mm",bg="white", device="pdf")

c<- ggarrange(plotlist=plots_cor)
c
ggsave(filename="../WGCNA_results/HPG/figure_kTotal_corr.png",c, height=210,width=210, units="mm",bg="white", device="png")
cor_out<- do.call("rbind",cor_out)
write.csv(cor_out,file="../WGCNA_results/HPG/results_kTotal_residuals.csv")


z<- ggarrange(plotlist=plots_IM)
z
ggsave(filename="../WGCNA_results/HPG/figure_kWithin_all.png",g, height=210,width=210, units="mm",bg="white", device="png")
```

How does module size influence connectivity?

```{r}
diffs2<- do.call("rbind",diffs)
ps<- as.data.frame(cbind(pvalues_total, q))
diffs2<- cbind(diffs2,ps)
module_size<- as.data.frame(table(color$moduleColor))
colnames(module_size)<- c("module","size")
diffs2<- merge(module_size, diffs2, by="module")
s<- ggplot(diffs2, aes(x=size,y=abs(median_diff), fill=module)) + geom_point(pch=21, size=2) + scale_fill_manual(values=levels(diffs2$module)) + geom_text_repel(aes(label=module), size=geom.text.size, hjust=-0.2) + peri_figure_supp + theme(legend.position = "none") + labs(x="module size", y="|Difference in median kTotal| (floater-territorial)")
s
ggsave(filename="../WGCNA_results/HPG/figure_size_diffkTotal.png",s, height=100,width=100, units="mm",bg="white", device="png")
```

```{r, eval=FALSE}
probes <- names(terr_dat)
inModule <- moduleColors=="navajowhite2" #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]
module_genes<- color[color$moduleColor=="navajowhite2",]


modTOM <- adjacency[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(terr_dat[, modProbes], power = 24, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
library(igraph)
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree

ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

# Module Preservation

```{r calc module preservation, eval=FALSE}
setLabels<-c("territorial","floater")
multiExpr<- list(territorial=list(data=terr_dat),floater=list(data=flo_dat))
multiColor<- list(territorial=color$moduleColor, floater=color$moduleColor)

mp=modulePreservation(multiExpr,multiColor, referenceNetworks=1, nPermutations=200, randomSeed=1, quickCor=0, verbose=3)

#Savetheresults 
save(mp,file="../WGCNA_results/HPG/terr_vs_flo_modulePreservation.RData")

```

```{r}
load("../WGCNA_results/HPG/terr_vs_flo_modulePreservation.RData")
ref=1
test=2

statsObs=cbind(mp$quality$observed[[ref]][[test]][,-1],mp$preservation$observed[[ref]][[test]][,-1])

statsZ=cbind(mp$quality$Z[[ref]][[test]][,-1],mp$preservation$Z[[ref]][[test]][,-1])

summary_out<- cbind(statsObs[,c("medianRank.pres","medianRank.qual")], signif(statsZ[,c("Zsummary.pres","Zsummary.qual")],2))


modColors=rownames(mp$preservation$observed[[ref]][[test]])
moduleSizes=mp$preservation$Z[[ref]][[test]][,1]
#leavegreyandgoldmodulesout 
plotMods=!(modColors%in%c("grey","gold")) 
#Textlabelsforpoints
text=modColors[plotMods]
#Auxiliaryconveniencevariable
plotData=cbind(mp$preservation$observed[[ref]][[test]][,2],mp$preservation$Z[[ref]][[test]][,2]) 
#Maintitlesfortheplot
mains=c("PreservationMedianrank","PreservationZsummary")
#Starttheplot sizeGrWindow(10,5); #pdf(fi="Plots/BxHLiverFemaleOnly-modulePreservation-Zsummary-medianRank.pdf",wi=10,h=5) 
par(mfrow=c(1,2)) 
par(mar=c(4.5,4.5,2.5,1)) 
for(p in 1:2){ 
  min=min(plotData[,p],na.rm=TRUE) 
  max=max(plotData[,p],na.rm=TRUE)
  #Adjustplotingrangesappropriately 
  if(p==2) 
  { 
    if(min>-max/10)min=-max/10
    ylim=c(min-0.1*(max-min),max+0.1*(max-min)) 
  }else 
    
    ylim=c(max+0.1*(max-min),min-0.1*(max-min))
    

plot(moduleSizes[plotMods],plotData[plotMods,p],col=1,bg=modColors[plotMods],pch=21, main=mains[p], cex=2.4, ylab=mains[p],xlab="Modulesize",log="x", ylim=ylim, xlim=c(10,2000),cex.lab=1.2,cex.axis=1.2,cex.main=1.4)

labelPoints(moduleSizes[plotMods],plotData[plotMods,p],text,cex=1,offs=0.08)

#ForZsummary,addthresholdlines 
  if(p==2) 
  { 
    abline(h=0) 
    abline(h=2,col="blue",lty=2)
    abline(h=10,col="darkgreen",lty=2) 
    } 
  }
```

```{r,eval=FALSE}
nSets=2
# This variable will contain the summary table
summaryTable = NULL
# Loop over all combinations of reference and tests sets
for (ref in 1:nSets) for (test in 1:nSets) if (ref!=test)
{
modules = rownames(mp$preservation$Z[[ref]][[test]]);
nMods = length(modules);
sizes = mp$preservation$Z[[ref]][[test]][, 1];
acc = matrix(NA, nMods, 3);
if (test!=4)
{
acc[match(rownames(mp$accuracy$observed[[ref]][[test]]), modules), ] =
mp$accuracy$observed[[ref]][[test]][, -1, drop = FALSE];
colnames(acc) = colnames(mp$accuracy$observed[[ref]][[test]])[-1];
accZ = mp$accuracy$Z[[ref]][[test]][, -1, drop = FALSE];
acc.log.p = mp$accuracy$log.p[[ref]][[test]][, -1, drop = FALSE];
acc.log.pBonf = mp$accuracy$log.pBonf[[ref]][[test]][, -1, drop = FALSE];
} else {
accZ = matrix(NA, nMods, 3);
acc.log.p = matrix(NA, nMods, 3);
acc.log.pBonf = matrix(NA, nMods, 3);
colnames(acc) = colnames(mp$accuracy$observed[[1]][[2]])[-1];
colnames(accZ) = colnames(mp$accuracy$Z[[1]][[2]])[-1];
colnames(acc.log.p) = colnames(mp$accuracy$log.p[[1]][[2]])[-1];
colnames(acc.log.pBonf) = colnames(mp$accuracy$log.pBonf[[1]][[2]])[-1];
}
# Table of results for this reference-test combination
tab = cbind(referenceSet = rep(setLabels[ref], nMods),
testSet = rep(setLabels[test], nMods),
moduleLabel = modules,
moduleSize = sizes,
mp$quality$observed[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$observed[[ref]][[test]][, -1, drop = FALSE],
acc,
mp$referenceSeparability$observed[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$observed[[ref]][[test]][, -1, drop = FALSE],
mp$quality$Z[[ref]][[test]][, -1, drop = FALSE],
mp$quality$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$quality$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$Z[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
accZ,
acc.log.p,
acc.log.pBonf,
mp$referenceSeparability$Z[[ref]][[test]][, -1, drop = FALSE],
mp$referenceSeparability$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$referenceSeparability$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$Z[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$log.pBonf[[ref]][[test]][, -1, drop = FALSE]

)
# Add the table to the main table.
if (is.null(summaryTable)) summaryTable = tab else summaryTable = rbind(summaryTable, tab);
}
# Save the table in csv format.
write.table(summaryTable, file ="../WGCNA_results/HPG/result_terr_vs_flo_module_preservation.csv", row.names = FALSE, sep = ",", quote = FALSE)
```


```{r pres}
pres<- read.csv("../WGCNA_results/HPG/result_terr_vs_flo_module_preservation.csv")

a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure_supp + scale_y_reverse()

b<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zsummary.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

c<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zdensity.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

d<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zconnectivity.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

e<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.separability.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp


f<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.propVarExplained.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

g<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanSignAwareKME.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

h<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanAdj.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

i<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kIM, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

j<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kME, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

k<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kMEall, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp






z<- ggarrange(a,b,c,d,e,f,g,h,i,j,k,labels=c(LETTERS[1:11]))
ggsave(filename="../WGCNA_results/HPG/figure_preservation_all.png",z, height=150,width=180, units="mm",bg="white", device="png")
ggsave(filename="../WGCNA_results/HPG/figure_preservation_all.pdf",z, height=150,width=180, units="mm",bg="white", device="pdf")

a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.pres, fill=moduleLabel)) + geom_point(pch=21, size=2, stroke=0.2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure + scale_y_reverse() + labs(y="Median Rank")
ggsave(filename="../WGCNA_results/HPG/figure_preservation_medianrank.pdf",a, height=40,width=35, units="mm",bg="white", device="pdf")
```

```{r quality}
a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure_supp + scale_y_reverse()

b<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zsummary.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

c<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.separability.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

d<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.propVarExplained.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

e<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanSignAwareKME.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

f<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanAdj.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp


z<- ggarrange(a,b,c,d,e,f,labels=c(LETTERS[1:6]))
ggsave(filename="../WGCNA_results/HPG/figure_quality_all.png",z, height=150,width=180, units="mm",bg="white", device="png")


```

