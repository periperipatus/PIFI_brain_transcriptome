---
title: "WGCNA Analyses Within-Tissues"
subtitle: "For manuscript: Neurogenomic landscape of male cooperative behavior in a wild bird "
date: Last Knit "`r Sys.Date()`"
author: "Peri Bolton"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE, fig.align="center", comment=FALSE)
```


```{r libraries and presets}
library(WGCNA)
enableWGCNAThreads()
options(stringsAsFactors = FALSE)
library(lubridate)
library(ggpubr)
library(flashClust)
library(plyr)
library(DESeq2)
library(pheatmap)
library(reshape2)
library(dplyr)
library(ggnetwork)
library(kableExtra)
library(igraph)
library(network)
library(AnnotationHub)
library(clusterProfiler)
library(org.Hs.eg.db)
library(enrichplot)
library(rrvgo)
library(viridis)
library(stringr)

peri_theme <- theme(panel.background = element_rect(fill="white"),panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
    axis.title.x = element_text(size = 12), axis.text.x = element_text(size = 10, 
        colour = "black"), axis.title.y = element_text(size = 12), 
    axis.text.y = element_text(size = 10, colour = "black"), 
    legend.text = element_text(size = 10), legend.title = element_text(size = 12), 
    axis.line.y = element_line(colour = "black"), axis.line.x = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5, size=12))  + theme(legend.key=element_blank())
dodge=position_dodge(0.8)
```

```{r data, echo=TRUE}
key<- read.csv("../data_filtered/data_key_Parsed_ReplicatesRemoved.csv")
behav<- read.csv("../data_unfiltered/PIPFIL_T_and_behav_data.csv")
rownames(key)<- key$X

key$Color_ID<- sub("/","", key$Color_ID)
key<- plyr::rename(key, replace=c("Color_ID"="colorID"))
behav$status<- plyr::revalue(behav$status, c("floa"="floater", "terr"="territorial"))
key_behav<- merge(key, behav, by="colorID")
key_behav<- key_behav[!is.na(key_behav$last_behav),]


#create a data.frame with all of the observations. 
not_in_behav<- key[!key$X %in% key_behav$X,]
cols_not_key<- colnames(key_behav)[!colnames(key_behav) %in% colnames(key)]
cols_not_key_df<- data.frame(matrix(NA, nrow = nrow(not_in_behav), ncol = length(cols_not_key)))
colnames(cols_not_key_df)<- cols_not_key
not_in_behav<- cbind(not_in_behav, cols_not_key_df)

key_behav<- rbind(key_behav, not_in_behav)

rownames(key_behav)<- key_behav$X
key_behav<- subset(key_behav, select=c("sampleID", "Year", "Tissue", "Batch", "Status", "Class", "mean_T", "strength.all_study"))
#key_behav$Class<- word(key_behav$Class,1)

key_behav$Tissue<- factor(key_behav$Tissue, levels=c("GON","PIT","VMH","AH","PVN","POM","ICO","GCT","AI","TNA","LS", "BSTm"))
key_behav<- key_behav[order(rownames(key_behav)),]
key_behav$Class<- plyr::revalue(key_behav$Class, replace=c("SCB floater"="Predefinitive floater", "DCB floater "="Definitive floater", "DCB territorial"="Territorial"))
key_behav$Class<- factor(key_behav$Class, levels=c("Predefinitive floater", "Definitive floater", "Territorial"))
rownames(key_behav)<- key_behav$sampleID
key_behav<- key_behav[order(key_behav$sampleID),]


#read the raw count data
data<- read.csv("../data_filtered/data_RawCounts_all_ReplicatesRemoved_antisense_V2.csv")

rownames(data)<- data$X
data$X<- NULL

genes_key<- read.csv("../GO_annotations/Maggies_annotations_modifiedR.csv")
genes_key<- plyr::rename(genes_key, replace=c("GeneID"="gene"))

data_genes<- data.frame(gene=rownames(data))
genes_key<- merge(data_genes, genes_key, by="gene", all.x=TRUE)

genes_key$display_gene_ID<- ifelse(is.na(genes_key$best_anno), as.character(genes_key$gene), ifelse(genes_key$best_anno!=genes_key$gene, paste0(genes_key$gene,"/", genes_key$best_anno), as.character(genes_key$best_anno))) 
  
  

                                

go_terms<- read.csv("../GO_annotations/pfil_GO_key_raw.csv")
go_terms<- plyr::rename(go_terms, replace=c("GeneID"="gene"))
go2gene_bp<- go_terms[which(go_terms$Aspect=="P"),c("GO_ID", "gene")]
go2gene_mf<- go_terms[which(go_terms$Aspect=="F"),c("GO_ID", "gene")]
go_obo<- read.csv("../GO_annotations/ontology_obo_out.csv")
go_obo<- plyr::rename(go_obo, replace=c("id"="GO_ID"))
go2name_bp<- go_obo[which(go_obo$namespace=="biological_process"),c("GO_ID", "name")]
go2name_mf<- go_obo[which(go_obo$namespace=="molecular_function"),c("GO_ID", "name")]


```


# Gonads (GON)

Like the DESeq2 document, the Gonads section will contain the code used throughout the the analysis to achieve the full set of results. First, each dataset is filtered conservatively as per the DESeq workflow, and then any batch effects identified in the DEseq workflow are removed here. Then we create a midweight bicorrelation weighted signed network using the recommended options. The Topological Overlap Matrix is also signed. 


```{r GON data processing, echo=TRUE}
tissue<- "GON"
gon_key<- subset(key_behav, Tissue==tissue)
gon_key<- droplevels(gon_key)

gon_data<- data[,colnames(data) %in% rownames(gon_key)]


start<- nrow(gon_data)
#remove genes with less than 5 reads
gon_data$avg_count<- apply(gon_data, 1, mean)
gon_data<- gon_data[gon_data$avg_count>5,]
gon_data$avg_count<-NULL
#gon_data$mad<- apply(gon_data,1,mad)
#gon_data$var<- apply(gon_data, 1, var) # could filter by variance rather than MAD maybe <0.2 but these filtering methods all seem to achieve this. 

#remove genes where >50% of samples have 0 gene expression
gon_data$percent_0<- apply(gon_data, 1, function(x)length(x[x==0]))
thresh<- ncol(gon_data)/2
gon_data<- gon_data[gon_data$percent_0<=thresh,]
gon_data$percent_0<-NULL


dd<- DESeqDataSetFromMatrix(countData=gon_data, colData=gon_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, gon_key$Batch)
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="GON_vsd_batch_rm.csv")
```


```{r GON soft-threshold, echo=TRUE}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=10
```

The rule will be we will pick the soft power that reaches scale free topology 

The adjacency matrix was run on an HPC to speed up run time and prevent overloading my personal computer. 

```{r GON adjacency matrix, eval=FALSE, echo=TRUE}


softPower=10

datExpr0<- read.csv("GON_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM

save(adjacency, dissTOM, file="GON_network.RData")
```


```{r, GON making modules, echo=TRUE}
load("../WGCNA_results/within_tissues/GON_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


#plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
#abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```


```{r GON correlate with traits, echo=TRUE, fig.asp=0.6}
datTraits<- gon_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T", "strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()
```

```{r GON extracting module information, echo=TRUE}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```

### Pink module 

```{r GON pink module}
whichModule="pink"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = whichModule)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gon_key), mean_T=gon_key[,"mean_T"], Status=gon_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

gone<- plotCounts(dd, gene="CHRNA3", intgroup=c("mean_T", "Class"), returnData=TRUE)
ggplot(gone, aes(x=mean_T, y=count)) + geom_point(size=2) + labs(title="CHRNA3 in GON",x="mean T", y="Normalised Counts") + peri_theme

```


```{r GON pink network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module


probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

#### Enrichment

```{r GON pink GO}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:14,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)



```



### salmon module

```{r GON salmon module}
whichModule="salmon"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = whichModule)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gon_key), mean_T=gon_key[,"mean_T"], Status=gon_key[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GON salmon network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

#### Enrichment

```{r GON salmon enrichment GO}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)



```


# Pituitary (PIT)

```{r PIT data processing}
keep<- c("data", "peri_theme", "key","key_behav","dodge","genes_key", "keep", "wp2gene", "wpid2gene","wpid2name","go2gene_mf","go2name_mf","go2gene_bp","go2name_bp")
rm(list= ls()[!(ls() %in% keep)])

tissue="PIT"
pit_key<- subset(key_behav, Tissue==tissue)
pit_key<- droplevels(pit_key)
pit_data<- data[,colnames(data) %in% rownames(pit_key)]


start<- nrow(pit_data)
#remove genes with less than 5 reads
pit_data$avg_count<- apply(pit_data, 1, mean)
pit_data<- pit_data[pit_data$avg_count>5,]
pit_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
pit_data$percent_0<- apply(pit_data, 1, function(x)length(x[x==0]))
thresh<- ncol(pit_data)/2
pit_data<- pit_data[pit_data$percent_0<=thresh,]
pit_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=pit_data, colData=pit_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, pit_key$Batch)
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="PIT_vsd_batch_rm.csv")
```


```{r PIT soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r PIT adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("PIT_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")

#dissTOM<- 1-TOM

save(adjacency, TOM, file="PIT_network.RData")
```



```{r, PIT making modules}
load("../WGCNA_results/within_tissues/PIT_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```


```{r PIT correlate with traits, fig.asp=0.8}
datTraits<- pit_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T", "strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()
```

```{r PIT extracting module information, echo=TRUE}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <- merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3, )
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)



```

## Interesting Modules

```{r}

# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```

It does not appear that our key strong module *floralwhite* is strongly linked with another.


### floralwhite module

```{r PIT floralwhite  module}
whichModule<- "floralwhite"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM

#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pit_key), strength=pit_key[,"strength.all_study"], Status=pit_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r PIT floralwhite network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[which(module_genes$gene %in% names(top)),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
#colnames(top30TOM)<- top_genes$display_gene_ID
#rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

This module is too influenced by PFT3. This is a sample I removed in the DESeq analysis. Disregard. 


### pink4

```{r PIT pink4 module}
whichModule<- "pink4"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pit_key), strength=pit_key[,"strength.all_study"], Status=pit_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r PIT pink3 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[which(module_genes$gene %in% names(top)),]

#not in module?
#names(top)[which(!names(top) %in% top_genes$gene)]
#LOC113988470

top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r PIT pink4 go}


## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste(tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste(tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)




```


# Ventromedial Hypothalamus (VMH)

```{r VMH data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue<- "VMH"

vmh_key<- subset(key_behav, Tissue==tissue)
vmh_key<- droplevels(vmh_key)
vmh_data<- data[,colnames(data) %in% rownames(vmh_key)]


start<- nrow(vmh_data)
#remove genes with less than 5 reads
vmh_data$avg_count<- apply(vmh_data, 1, mean)
vmh_data<- vmh_data[vmh_data$avg_count>5,]
vmh_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
vmh_data$percent_0<- apply(vmh_data, 1, function(x)length(x[x==0]))
thresh<- ncol(vmh_data)/2
vmh_data<- vmh_data[vmh_data$percent_0<=thresh,]
vmh_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=vmh_data, colData=vmh_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, vmh_key$Batch)
datExpr0<- as.data.frame(t(mat))
#gsg = goodSamplesGenes(datExpr0, verbose = 3)
#gsg$allOK
#write.csv(datExpr0, file="VMH_vsd_batch_rm.csv")
```


```{r VMH soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r VMH adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("VMH_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM

save(adjacency, TOM, file="VMH_network.RData")


```

```{r VMH making modules}
load("../WGCNA_results/within_tissues/VMH_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r VMH correlate with traits, fig.asp=0.8}
datTraits<- vmh_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()
```

```{r VMH extracting module information, echo=TRUE}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)




```

## Interesting Modules


```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```

### lightcoral module

```{r VMH lightcoral module}
whichModule<- "lightcoral"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(vmh_key), mean_T=vmh_key[,"mean_T"], Status=vmh_key[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="RAB3IL1", intgroup=c("mean_T", "Status"), returnData=TRUE)
#ggplot(gone, aes(x=Status, y=count)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme + geom_boxplot(fill=NA)
```

The top hub gene was not significantly associated with either mean_T or Status in the DESeq analysis. 

```{r VMH lightcoral network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r VMH lightcoral go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)




```




# Anterior Hypothalamus (AH)

```{r AH data processing}
rm(list= ls()[!(ls() %in% keep)])

tissue<- "AH"
ah_key<- subset(key_behav, Tissue==tissue)
ah_key<- droplevels(ah_key)
ah_key$Year<- as.factor(ah_key$Year)
#ah_behav<- subset(key_behav, Tissue=="AH")
#ah_behav<- droplevels(ah_behav)
ah_data<- data[,colnames(data) %in% rownames(ah_key)]


start<- nrow(ah_data)
#remove genes with less than 5 reads
ah_data$avg_count<- apply(ah_data, 1, mean)
ah_data<- ah_data[ah_data$avg_count>5,]
ah_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
ah_data$percent_0<- apply(ah_data, 1, function(x)length(x[x==0]))
thresh<- ncol(ah_data)/2
ah_data<- ah_data[ah_data$percent_0<=thresh,]
ah_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=ah_data, colData=ah_key, design= ~ Year)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, ah_key$Year)
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="AH_vsd_year_rm.csv")
```


```{r AH soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r AH adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.
softPower=18

datExpr0<- read.csv("AH_vsd_year_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM, file="AH_network.RData")

```

```{r AH making modules}
load("../WGCNA_results/within_tissues/AH_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r AH correlate with traits, fig.asp=0.8}
datTraits<- ah_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()

```

```{r AH extracting module information}

#### module membership


datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)



```

## Interesting Modules

```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```

Negatively related to the tan module. 

### mediumpurple1 module

```{r AH mediumpurple1 module}
whichModule<- "mediumpurple1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.status"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col=whichModule)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ah_key), mean_T=ah_key[,"mean_T"], Status=ah_key[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="FTSJ3", intgroup=c("mean_T", "Status"), returnData=TRUE)
#ggplot(gone, aes(x=Status, y=count)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme + geom_boxplot(fill=NA)
```

```{r AH mediumpurple1 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####

## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r AH mediumpurple1 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)


### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

```



### tan module

```{r AH tan module}
whichModule<- "tan"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.status"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col=whichModule)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ah_key), mean_T=ah_key[,"mean_T"], Status=ah_key[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="FTSJ3", intgroup=c("mean_T", "Status"), returnData=TRUE)
#ggplot(gone, aes(x=Status, y=count)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme + geom_boxplot(fill=NA)
```

```{r AH tan network plotting TOM}
##### TOM BASED NETWORK ####

## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r AH tan go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

```



# Paraventricular Nucleus (PVN)

```{r PVN data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue="PVN"
pvn_key<- subset(key_behav, Tissue==tissue)
pvn_key<- droplevels(pvn_key)
#pvn_behav<- subset(key_behav, Tissue=="PVN")
#pvn_behav<- droplevels(pvn_behav)
pvn_data<- data[,colnames(data) %in% rownames(pvn_key)]


start<- nrow(pvn_data)
#remove genes with less than 5 reads
pvn_data$avg_count<- apply(pvn_data, 1, mean)
pvn_data<- pvn_data[pvn_data$avg_count>5,]
pvn_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
pvn_data$percent_0<- apply(pvn_data, 1, function(x)length(x[x==0]))
thresh<- ncol(pvn_data)/2
pvn_data<- pvn_data[pvn_data$percent_0<=thresh,]
pvn_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=pvn_data, colData=pvn_key, design= ~ Status)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
#mat<- limma::removeBatchEffect(vsd_data, pvn_key$Batch) #there  is no batch effects in the PVN
datExpr0<- as.data.frame(t(vsd_data))
#gsg = goodSamplesGenes(datExpr0, verbose = 3)
#gsg$allOK
#write.csv(datExpr0, file="PVN_vsd.csv")
```


```{r PVN soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=9
```


```{r PVN adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=9

datExpr0<- read.csv("PVN_vsd.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM,  file="PVN_network.RData")
```

```{r PVN making modules}
load("../WGCNA_results/within_tissues/PVN_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r PVN correlate with traits, fig.asp=0.8}
datTraits<- pvn_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()
```

```{r PVN extracting module information}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```

## Interesting Modules


```{r}

# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```

It doesn't appear that our interesting module *white* is associated with any other module of interest. 

### white module

```{r PVN lightpink4 module}
whichModule<- "white"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.status"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for Status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pvn_key), mean_T=pvn_key[,"mean_T"], Status=pvn_key[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r PVN white network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r PVN white go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



# Medial Preoptic Area (POM)

Note that the PFT2 POM sample was removed from this analysis as other analyses found this to be an outlier.

```{r POM data processing}
rm(list= ls()[!(ls() %in% keep)])

outliers=c("PFT2_POM_run1")
tissue="POM"
pom_key<- subset(key_behav, Tissue==tissue)
pom_key<- pom_key[!rownames(pom_key) %in% outliers,]
pom_key<- droplevels(pom_key)
#pom_behav<- subset(key_behav, Tissue=="POM")
#pom_behav<- droplevels(pom_behav)
pom_data<- data[,colnames(data) %in% rownames(pom_key)]


start<- nrow(pom_data)
#remove genes with less than 5 reads
pom_data$avg_count<- apply(pom_data, 1, mean)
pom_data<- pom_data[pom_data$avg_count>5,]
pom_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
pom_data$percent_0<- apply(pom_data, 1, function(x)length(x[x==0]))
thresh<- ncol(pom_data)/2
pom_data<- pom_data[pom_data$percent_0<=thresh,]
pom_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=pom_data, colData=pom_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, pom_key$Batch)
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="POM_vsd_batch_rm.csv")
```


```{r POM soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=20
```


```{r POM adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=20

datExpr0<- read.csv("POM_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM, file="POM_network.RData")
```


```{r POM making modules}
load("../WGCNA_results/within_tissues/POM_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.35 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r POM correlate with traits, fig.asp=0.8}
datTraits<- pom_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T", "strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()





```

```{r POM extracting module information}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)






```

## Interesting Modules

```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```



### floralwhite

Good positive relationship with Status/mean T

```{r POM floralwhite module}
whichModule<- "floralwhite"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pom_key), mean_T=pom_key[,"mean_T"], Status=pom_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r POM floral white network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r POM floralwhite go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)





```




### pink3

```{r POM pink3 module}
whichModule<- "pink3"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pom_key), Status=pom_key[,"Status"], strength=pom_key[,"strength.all_study"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r POM pink3 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r POM pink3 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)





```



### mediumpurple1

```{r POM mediumpurple1 module}
whichModule<- "mediumpurple1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]

verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean T",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pom_key), Status=pom_key[,"Status"], mean_T=pom_key[,"mean_T"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r POM mediumpurple1 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r POM mediumpurple1 go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)




```



### sienna3
```{r POM sienna3 module}
whichModule<- "sienna3"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]

verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(pom_key), strength=pom_key[,"strength.all_study"], Status=pom_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r POM sienna3 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r POM sienna3 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)




```

# Dorsomedial Intercollicular Nucleus (ICo)

```{r ICO data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue="ICO"
ico_key<- subset(key_behav, Tissue==tissue)
ico_key<- droplevels(ico_key)
#ico_behav<- subset(key_behav, Tissue=="ICO")
#ico_behav<- droplevels(ico_behav)
ico_data<- data[,colnames(data) %in% rownames(ico_key)]


start<- nrow(ico_data)
#remove genes with less than 5 reads
ico_data$avg_count<- apply(ico_data, 1, mean)
ico_data<- ico_data[ico_data$avg_count>5,]
ico_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
ico_data$percent_0<- apply(ico_data, 1, function(x)length(x[x==0]))
thresh<- ncol(ico_data)/2
ico_data<- ico_data[ico_data$percent_0<=thresh,]
ico_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=ico_data, colData=ico_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, ico_key$Batch) 
datExpr0<- as.data.frame(t(mat))
#gsg = goodSamplesGenes(datExpr0, verbose = 3)
#gsg$allOK
#write.csv(datExpr0, file="ICO_vsd_batch_rm.csv")
```


```{r ICO soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r ICO adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("ICO_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM, file="ICO_network.RData")
```

```{r ICO making modules}
load("../WGCNA_results/within_tissues/ICO_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r ICO correlate with traits, fig.asp=0.8}
datTraits<- ico_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T", "strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()

```

```{r ICO extracting module information}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)



trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```
 
There appears to be no correlations between modules of interest. 

### lavenderblush2

```{r ICO lavenderblush2 module}
whichModule<- "lavenderblush2"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ico_key), strength=ico_key[,"strength.all_study"], Status=ico_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r ICO lavenderblush2 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r ICO lavenderblush2 go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### darkturquoise

```{r ICO darkturquoise module}
whichModule<- "darkturquoise"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ico_key), mean_T=ico_key[,"mean_T"], Status=ico_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r ICO darkturquoise network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r ICO darkturquoise go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### maroon

```{r ICO maroon module}
whichModule<- "maroon"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ico_key), mean_T=ico_key[,"mean_T"], Status=ico_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="VIPR1", intgroup=c("mean_T", "Status"), returnData=TRUE)
#ggplot(gone, aes(x=mean_T, y=count, color=Status)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme 
#+ geom_boxplot(fill=NA)
```

```{r ICO maroon network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r ICO maroon go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### dark turquoise

```{r ICO turquoise module}
whichModule<- "darkturquoise"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ico_key), mean_T=ico_key[,"mean_T"], Status=ico_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="CCDC33", intgroup=c("mean_T", "Status"), returnData=TRUE)
#ggplot(gone, aes(x=mean_T, y=count, color=Status)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme 
#+ geom_boxplot(fill=NA)
```

```{r ICO turquoise network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r ICO turqoise go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


# Midbrain Central Grey (GCT)

```{r GCT data processing}

rm(list= ls()[!(ls() %in% keep)])
tissue="GCT"
gct_key<- subset(key_behav, Tissue==tissue)
gct_key<- droplevels(gct_key)
#gct_behav<- subset(key_behav, Tissue=="GCT")
#gct_behav<- droplevels(gct_behav)
gct_data<- data[,colnames(data) %in% rownames(gct_key)]


start<- nrow(gct_data)
#remove genes with less than 5 reads
gct_data$avg_count<- apply(gct_data, 1, mean)
gct_data<- gct_data[gct_data$avg_count>5,]
gct_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
gct_data$percent_0<- apply(gct_data, 1, function(x)length(x[x==0]))
thresh<- ncol(gct_data)/2
gct_data<- gct_data[gct_data$percent_0<=thresh,]
gct_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=gct_data, colData=gct_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, gct_key$Batch) 
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="GCT_vsd_batch_rm.csv")
```


```{r GCT soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r GCT adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("GCT_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM, file="GCT_network.RData")
```

```{r GCT making modules}
load("../WGCNA_results/within_tissues/GCT_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r GCT correlate with traits, fig.asp=0.8}
datTraits<- gct_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()

```

```{r GCT extracting module information}

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```
 
There appears to be a strong correlation between *skyblue2* and *green4*

### skyblue2

```{r GCT skyblue2 module, eval=FALSE}
whichModule<- "skyblue2"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), strength=gct_key[,"strength.all_study"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT skyblue2 network plotting TOM, eval=FALSE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```



### green4
```{r GCT green4 module, eval=FALSE}
whichModule<- "green4"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), strength=gct_key[,"strength.all_study"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT green4 network plotting TOM, eval=FALSE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```


### lightpink3

```{r GCT lightpink3 module}
whichModule<- "lightpink3"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), mean_T=gct_key[,"mean_T"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT lightpink3 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r GCT lightpink3 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### antiquewhite1

```{r GCT antiquewhite1 module}
whichModule<- "antiquewhite1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), strength=gct_key[,"strength.all_study"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT antiquewhite1 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r GCT antiquewhite1 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### antiquewhite2

```{r GCT antiquewhite2 module}
whichModule<- "antiquewhite2"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), strength=gct_key[,"strength.all_study"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT antiquewhite2 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r GCT antiquewhite2 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```

### coral1

```{r GCT coral1 module}
whichModule<- "coral1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean Testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(gct_key), strength=gct_key[,"strength.all_study"], Status=gct_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r GCT coral1 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r GCT coral1 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


# Nucleus Taenia (TnA)

```{r TNA data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue="TNA"
tna_key<- subset(key_behav, Tissue==tissue)

tna_key<- droplevels(tna_key)
#tna_behav<- subset(key_behav, Tissue=="TNA")
#tna_behav<- droplevels(tna_behav)
tna_data<- data[,colnames(data) %in% rownames(tna_key)]


start<- nrow(tna_data)
#remove genes with less than 5 reads
tna_data$avg_count<- apply(tna_data, 1, mean)
tna_data<- tna_data[tna_data$avg_count>5,]
tna_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
tna_data$percent_0<- apply(tna_data, 1, function(x)length(x[x==0]))
thresh<- ncol(tna_data)/2
tna_data<- tna_data[tna_data$percent_0<=thresh,]
tna_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=tna_data, colData=tna_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, tna_key$Batch)
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="TNA_vsd_batch_rm.csv")
```


```{r TNA soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed", corFnc="bicor", corOptions=list(use="p", maxPOutliers=0.1))


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```



```{r TNA adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("TNA_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, dissTOM, file="TNA_network.RData")
```
 
 

```{r TNA making modules}
load("../WGCNA_results/within_tissues/TNA_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.35 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r TNA correlate with traits, fig.asp=0.8}
datTraits<- tna_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()



```

```{r TNA extracting module information}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```



## Interesting modules

Based on inspection of the module memberships it seems that *coral1* is the inverse of *blue*

```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
a<-ggplot(MEs, aes(x=MEblue, y=MEcoral1)) + geom_point() + peri_theme
b<- ggplot(MEs, aes(x=MElightyellow, y=MEcoral1)) + geom_point() + peri_theme
ggarrange(a,b)
```

Coral1 is negatively related to blue

### coral1



```{r TNA coral1 module}
whichModule<- "coral1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(tna_key), mean_T=tna_key[,"mean_T"], Status=tna_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

gone<- plotCounts(dd, gene="RAB3IL1", intgroup=c("mean_T", "Status"), returnData=TRUE)
ggplot(gone, aes(x=Status, y=count)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme + geom_boxplot(fill=NA)
```

```{r TNA coral1 network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r TNA coral1 go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))


ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()



ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



### blue
```{r TNA blue module}
whichModule<- "blue"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(tna_key), mean_T=tna_key[,"mean_T"], Status=tna_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r TNA blue network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r TNA blue go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


### lightyellow

```{r TNA lightyellow module}
whichModule<- "lightyellow"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(tna_key), mean_T=tna_key[,"mean_T"], Status=tna_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r TNA lightyellow network plotting TOM, echo=TRUE}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r TNA lightyellow go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```

# Arcopallium Intermedium (AI)

```{r AI data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue="AI"
ai_key<- subset(key_behav, Tissue==tissue)
ai_key<- droplevels(ai_key)
#ai_behav<- subset(key_behav, Tissue=="AI")
#ai_behav<- droplevels(ai_behav)
ai_data<- data[,colnames(data) %in% rownames(ai_key)]


start<- nrow(ai_data)
#remove genes with less than 5 reads
ai_data$avg_count<- apply(ai_data, 1, mean)
ai_data<- ai_data[ai_data$avg_count>5,]
ai_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
ai_data$percent_0<- apply(ai_data, 1, function(x)length(x[x==0]))
thresh<- ncol(ai_data)/2
ai_data<- ai_data[ai_data$percent_0<=thresh,]
ai_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=ai_data, colData=ai_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, ai_key$Batch) 
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="AI_vsd_batch_rm.csv")
```


```{r AI soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=18
```


```{r AI adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=18

datExpr0<- read.csv("AI_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, dissTOM, file="AI_network.RData")
```


```{r AI making modules}
load("../WGCNA_results/within_tissues/AI_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r AI correlate with traits, fig.asp=0.8}
datTraits<- ai_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T", "strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()

```

```{r AI extracting module information}

#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)

```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main = "", legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```
 
Of our interesting modules, it appears that *thistle1* is negatively correlated with *skyblue2*

### thistle1

```{r AI thistle1 module}
whichModule<- "thistle1"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ai_key), mean_T=ai_key[,"mean_T"], Status=ai_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

#gone<- plotCounts(dd, gene="ACTB", intgroup=c("sampleID","mean_T"), returnData=TRUE)
#ggplot(gone, aes(x=mean_T, y=count)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme + geom_text(aes(label=sampleID))
```

```{r AI thistle1 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r thistle1 go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



### skyblue2

```{r AI skyblue2 module}
whichModule<- "skyblue2"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ai_key), mean_T=ai_key[,"mean_T"], Status=ai_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r AI skyblue2 network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r skyblue2 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```

### palevioletred3

```{r AI palevioletred3 module}
whichModule<- "palevioletred3"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ai_key), mean_T=ai_key[,"mean_T"], Status=ai_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

Not very convincing relationship

```{r AI palevioletred network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r palevioletred3 go}

## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



### lightcoral

```{r AI lightcoral module}
whichModule<- "lightcoral"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.mean_T"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for mean testosterone",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ai_key), mean_T=ai_key[,"mean_T"], Status=ai_key[,"Status"])
expDesign<- expDesign[order(expDesign$mean_T),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

Not a convincing relationship. 

# Lateral Septum (LS)

```{r LS data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue<-"LS"
ls_key<- subset(key_behav, Tissue==tissue)
ls_key<- droplevels(ls_key)
#ls_behav<- subset(key_behav, Tissue=="LS")
#ls_behav<- droplevels(ls_behav)
ls_data<- data[,colnames(data) %in% rownames(ls_key)]


start<- nrow(ls_data)
#remove genes with less than 5 reads
ls_data$avg_count<- apply(ls_data, 1, mean)
ls_data<- ls_data[ls_data$avg_count>5,]
ls_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
ls_data$percent_0<- apply(ls_data, 1, function(x)length(x[x==0]))
thresh<- ncol(ls_data)/2
ls_data<- ls_data[ls_data$percent_0<=thresh,]
ls_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=ls_data, colData=ls_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, ls_key$Batch) 
datExpr0<- as.data.frame(t(mat))
#gsg = goodSamplesGenes(datExpr0, verbose = 3)
#gsg$allOK
#write.csv(datExpr0, file="LS_vsd_batch_rm.csv")
```


```{r LS soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=16
```


```{r LS adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=16

datExpr0<- read.csv("LS_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, dissTOM, file="LS_network.RData")
```

```{r LS making modules}
load("../WGCNA_results/within_tissues/LS_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r LS correlate with traits, fig.asp=0.8}
datTraits<- ls_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))



knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()

```

```{r LS extracting module information}
#### module membership

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)
```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE,legend_breaks = c(-1,-0.5,0,0.5, 1,1), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"), main=paste("module eigengene correlations in", tissue, sep=" "))
```


There doesn't appear to be any obviously negative correlations with our modules of interest. 

### darkmagenta

```{r LS darkmagenta module}
whichModule<- "darkmagenta"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ls_key), strength=ls_key[,"strength.all_study"], Status=ls_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)

gone<- plotCounts(dd, gene="YPEL2", intgroup=c("mean_T", "Status"), returnData=TRUE)
ggplot(gone, aes(x=mean_T, y=count, color=Status)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme 
```

```{r LS darkmagenta network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r LS darkmagenta go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-pvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()


ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



### black

```{r LS black module}
whichModule<- "black"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for social network strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(ls_key), strength=ls_key[,"strength.all_study"], Status=ls_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)


gone<- plotCounts(dd, gene="MIER3", intgroup=c("strength.all_study", "Status"), returnData=TRUE)
ggplot(gone, aes(x=strength.all_study, y=count, color=Status)) + geom_point(size=2) + labs(title="",x="mean T", y="Normalised Counts") + peri_theme 
```

```{r LS black network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r LS black go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```


# Bed Nucleus of the Stria Terminalis (BSTm)
```{r BSTm data processing}
rm(list= ls()[!(ls() %in% keep)])
tissue="BSTm"
bstm_key<- subset(key_behav, Tissue==tissue)
bstm_key<- droplevels(bstm_key)

#bstm_behav<- subset(key_behav, Tissue=="BSTm")
#bstm_behav<- droplevels(bstm_behav)
bstm_data<- data[,colnames(data) %in% rownames(bstm_key)]


start<- nrow(bstm_data)
#remove genes with less than 5 reads
bstm_data$avg_count<- apply(bstm_data, 1, mean)
bstm_data<- bstm_data[bstm_data$avg_count>5,]
bstm_data$avg_count<-NULL


#remove genes where >50% of samples have 0 gene expression
bstm_data$percent_0<- apply(bstm_data, 1, function(x)length(x[x==0]))
thresh<- ncol(bstm_data)/2
bstm_data<- bstm_data[bstm_data$percent_0<=thresh,]
bstm_data$percent_0<-NULL

dd<- DESeqDataSetFromMatrix(countData=bstm_data, colData=bstm_key, design= ~ Batch)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]
vsd_data<- getVarianceStabilizedData(dd)
mat<- limma::removeBatchEffect(vsd_data, bstm_key$Batch) 
datExpr0<- as.data.frame(t(mat))
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
#write.csv(datExpr0, file="BSTm_vsd_batch_rm.csv")
```


```{r BSTm soft-threshold}
powers<- c(seq(1, 11, by = 1), seq(12, 26, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=22
```


```{r BSTm adjacency matrix, eval=FALSE}
#This component is run on the server as my computational capacity is not sufficient.

softPower=22

datExpr0<- read.csv("BSTm_vsd_batch_rm.csv")
rownames(datExpr0)<- datExpr0$X
datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMtype="signed")
#dissTOM<- 1-TOM


save(adjacency, TOM, file="BSTm_network.RData")
```


```{r BSTm making modules}
load("../WGCNA_results/within_tissues/BSTm_network.RData")
dissTOM<- 1-TOM
geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


#plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")

#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs
```

```{r BSTm correlate with traits, fig.asp=0.8}
datTraits<- bstm_key
all.equal(rownames(datExpr0), rownames(datTraits))


datTraits$sampleID<- as.numeric(as.factor(datTraits$sampleID))
datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("sampleID",  "Status2", "mean_T","strength.all_study"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"
names(datTraits)[names(datTraits)=="sampleID"] <- "Individual"


#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
moduleTraitPadj=p.adjust(moduleTraitPvalue, method="BH")
dim(moduleTraitPadj) <- dim(moduleTraitPvalue)
colnames(moduleTraitPadj) <- colnames(moduleTraitPvalue)
rownames(moduleTraitPadj) <- rownames(moduleTraitPvalue)

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)

par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in", tissue))

knitr::kable(table(moduleColors), caption = paste("Genes per module in", tissue)) %>% kable_styling()



```

```{r BSTm extracting module information}

datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <-  merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/within_tissues/",tissue,"results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)

#### gene-significance
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)



trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file=paste("../WGCNA_results/within_tissues/",tissue, "results_GeneSignificance.csv", sep="_"), row.names = FALSE)
```

## Interesting modules
```{r}
# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main=paste("module eigengene correlations in", tissue, sep=" "), legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```
 
There appears to be a strong correlation between *darkred* and *salmon4*, and inverse between *darkmagenta* and *paleturquoise*

### darkred

```{r BSTm darkred module}
whichModule<- "darkred"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(bstm_key), strength=bstm_key[,"strength.all_study"], Status=bstm_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r BSTm darkred network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r BSTm darkred go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))


ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

ggplot(ego@result[1:20,], aes(x=Description, y=GeneRatio, fill=pvalue)) + geom_bar(stat="identity") + peri_theme

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```



### darkmagenta

```{r BSTm darkmagenta module}
whichModule<- "darkmagenta"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(bstm_key), strength=bstm_key[,"strength.all_study"], Status=bstm_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r BSTm darkmagenta network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r BSTm darkmagenta go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- ego@result
ego2$GeneRatio2<- word(ego2$GeneRatio, 1,1, sep="/")
ego2$GeneRatio2<- as.numeric(ego2$GeneRatio2)

ggplot(ego2[1:10,], aes(x=Description, y=GeneRatio2, fill=-qvalue)) + geom_bar(stat="identity") + theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + coord_flip() + peri_theme + scale_y_continuous(expand=c(0,0)) + xlab("") + ylab("No genes enriched") + scale_fill_viridis()

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```

### saddlebrown

```{r BSTm saddlebrown module}
whichModule<- "saddlebrown"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.strength"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for strength",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(bstm_key), strength=bstm_key[,"strength.all_study"], Status=bstm_key[,"Status"])
expDesign<- expDesign[order(expDesign$strength),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in",tissue), annotation_row=expDesign, annotation_colors=ann_cols)
```

```{r BSTm saddlebrown network plotting TOM}
##### TOM BASED NETWORK ####
## get names of genes from the module
probes <- names(datExpr0)
inModule <- moduleColors==whichModule #creates logical vector of whether that gene is in the module
modProbes <- probes[inModule]


# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule] #TOM object does not have any gene names so need to use the positional information from the logical vector.

dimnames(modTOM) <- list(modProbes, modProbes)

IMConn<- softConnectivity(datExpr0[, modProbes], power = softPower, type="signed")
names(IMConn)<- modProbes
IMConn<- sort(IMConn, decreasing=T) #rank by highest connectivity
nTop<-30
top<- IMConn[1:nTop] #Take the top genes 
top30TOM<- modTOM[names(top),names(top)] 
#rename the TOM columns and rows to reflect the locno + gene ID. 
top_genes<- module_genes[module_genes$gene %in% names(top),]
top_genes<- top_genes[match(names(top), top_genes$gene), ]
colnames(top30TOM)<- top_genes$display_gene_ID
rownames(top30TOM)<- top_genes$display_gene_ID
vis = exportNetworkToVisANT(top30TOM,
weighted = TRUE,
threshold = 0.00)
#take the top 25% of TOM connections
vis<- vis[vis$weight>summary(vis$weight)[5],]
CoExpGraph <- graph.data.frame(vis, directed=FALSE)
nDegree <- degree(CoExpGraph, v=V(CoExpGraph), mode=c("total"))
V(CoExpGraph)$degree <- nDegree
#plot.igraph(CoExpGraph, edge.width=E(CoExpGraph)$weight, vertex.size= (V(CoExpGraph)$degree), vertex.frame.color=NA)


ggplot(ggnetwork(CoExpGraph, layout=with_fr()), aes(x = x, y = y, xend = xend, yend = yend))+geom_edges(aes(color=weight))+geom_nodes(aes(x,y, size=degree),color="black", alpha=0.7) +scale_color_gradient(low="#ffd71f", high="#e50000")+theme_blank()+ geom_nodetext_repel(aes(label=name))
```

```{r BSTm saddlebrown go}
## Biological Process
ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

### Molecular Function

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_mf,
                TERM2NAME=go2name_mf)

knitr::kable(ego@result[1:10,], caption=paste0("MF enriched GO terms in ", whichModule," module in ",tissue), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/within_tissues/",tissue, whichModule, "GO_MF.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="MF",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
```

```{r}
sessionInfo()
```

