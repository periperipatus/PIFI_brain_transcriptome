---
title: "Whole brain Co-expression"
subtitle: "For manuscript: Neurogenomic landscape of male cooperative behavior in a wild bird "
date: Last Knit "`r Sys.Date()`"
author: "Last Substantive Change December 2023"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE, fig.align="center", comment=FALSE)
```

```{r libraries}
library(WGCNA)
library(car)
library(flashClust)
library(plyr)
library(DESeq2)
library(PCAtools)
library(pheatmap)
library(kableExtra)
library(ggpubr)
library(clusterProfiler)
library(rrvgo)
library(ggfortify)
library(reshape2)
library(igraph)
library(ggnetwork)
library(effectsize)
library(dplyr)
enableWGCNAThreads()
options(stringsAsFactors = FALSE)


source("config.R")
```

```{r data}
key<- read.csv("../data_filtered/data_key_Parsed_ReplicatesRemoved.csv")
behav<- read.csv("../data_unfiltered/PIPFIL_T_and_behav_data.csv")
rownames(key)<- key$X

key$Color_ID<- sub("/","", key$Color_ID)
key<- plyr::rename(key, replace=c("Color_ID"="colorID"))
behav$status<- plyr::revalue(behav$status, c("floa"="floater", "terr"="territorial"))
key_behav<- merge(key, behav, by="colorID")
key_behav<- key_behav[!is.na(key_behav$last_behav),]


key_behav<- key_behav[order(key_behav$X),]

#create a data.frame with all of the observations. 
not_in_behav<- key[!key$X %in% key_behav$X,]
cols_not_key<- colnames(key_behav)[!colnames(key_behav) %in% colnames(key)]
cols_not_key_df<- data.frame(matrix(NA, nrow = nrow(not_in_behav), ncol = length(cols_not_key)))
colnames(cols_not_key_df)<- cols_not_key
not_in_behav<- cbind(not_in_behav, cols_not_key_df)

key_behav<- rbind(key_behav, not_in_behav)



data<- read.csv("../data_filtered/data_RawCounts_all_ReplicatesRemoved_antisense_V2.csv")
data$X[data$X=="LOC113993669"] <- "CYP19A1"
data$X[data$X=="LOC113983511"] <- "OXT"
data$X[data$X=="LOC113983498"] <- "AVP"
data$X[data$X=="LOC113982601"] <- "AVPR2"
rownames(data)<- data$X
data$X<- NULL




```

```{r gene annot}
genes_key<- read.csv("../GO_annotations/Maggies_annotations_modifiedR.csv")
genes_key<- plyr::rename(genes_key, replace=c("GeneID"="gene"))
genes_key$gene[genes_key$gene=="LOC113993669"] <- "CYP19A1"
genes_key$gene[genes_key$gene=="LOC113983511"] <- "OXT"
genes_key$gene[genes_key$gene=="LOC113983498"] <- "AVP"
genes_key$gene[genes_key$gene=="LOC113982601"] <- "AVPR2"
data_genes<- data.frame(gene=rownames(data))
genes_key<- merge(data_genes, genes_key, by="gene", all.x=TRUE)
#genes_key<- genes_key[which(grepl("LOC[0-9]+",genes_key$gene)),]

genes_key$display_gene_ID<- ifelse(grepl("LOC[0-9]+", genes_key$gene) & !grepl("LOC[0-9]+",genes_key$best_anno) & !is.na(genes_key$best_anno), paste0(genes_key$gene," (",genes_key$best_anno,")"), as.character(genes_key$gene))
genes_key<- genes_key[,c("gene","best_anno","display_gene_ID")]

  
  

go_terms<- read.csv("../GO_annotations/pfil_GO_key_raw.csv")
go_terms<- plyr::rename(go_terms, replace=c("GeneID"="gene"))
go2gene_bp<- go_terms[which(go_terms$Aspect=="P"),c("GO_ID", "gene")]
go2gene_mf<- go_terms[which(go_terms$Aspect=="F"),c("GO_ID", "gene")]
go_obo<- read.csv("../GO_annotations/ontology_obo_out.csv")
go_obo<- plyr::rename(go_obo, replace=c("id"="GO_ID"))
go2name_bp<- go_obo[which(go_obo$namespace=="biological_process"),c("GO_ID", "name")]
go2name_mf<- go_obo[which(go_obo$namespace=="molecular_function"),c("GO_ID", "name")]

```

<br><br>

In [Horton et al (2020)](https://onlinelibrary.wiley.com/doi/full/10.1111/gbb.12560), they identified bunches of genes with similar expression patterns (co-expression modules) that aligned with differences among brain nuclei. The co-expression analysis here (using WGCNA), has two aims:

* Replicate the results of Horton et al (2020)

* To identify if there are co-expression modules that are shared amongst brain regions that are associated with our traits of interest.

This second aim is in part a complement to the whole brain PCA analysis done in the [DESeq2 document](https://periperipatus.github.io/PIFI_brain_transcriptome/02_DESeq2_FINAL.html). 

# Data Quality Control

This is where I originally ran the test on the effect of batch correction on the whole brain dataset (now also presented in the [DESeq2 document](https://periperipatus.github.io/PIFI_brain_transcriptome/02_DESeq2_FINAL.html)). As identified in that document and the QC process, `PFT2_POM` sample was removed from this analysis.
 


```{r, wholebrain set up}

#identified as a consistent outlier
outliers=c("PFT2_POM_run1")
key_brain<- key_behav[key_behav$Tissue!="GON",]
key_brain<- key_brain[key_brain$Tissue!="PIT",]
key_brain<- key_brain[!key_brain$X %in% outliers,]
rownames(key_brain)<- key_brain$X
#
data<- data[, colnames(data) %in% key_brain$X]
###filter out lowly expressed genes
#
##remove genes with less than 20 reads
data$avg_count<- apply(data, 1, mean)
data<- data[data$avg_count>20,]
data$avg_count<-NULL


dd<- DESeqDataSetFromMatrix(countData=data, colData=key_brain, design= ~ Tissue)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]

vsd_data<- getVarianceStabilizedData(dd)
#p <- pca(vsd_data, metadata = key_brain)
#biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", #title="PCA all brain nuclei")
#pairsplot(p, colby="Tissue", triangle = FALSE, shape="Batch")
##eigencorplot(p, metavars = c("Batch","Year", "Status","Tissue"))
```

## Connectivity Test for Outliers

```{r}
wgcnadata<- as.data.frame(t(vsd_data))

gsg = goodSamplesGenes(wgcnadata, verbose = 3)
gsg$allOK


traits<- key_brain[, c("Batch",  "Year")]
traits$pilot<- as.numeric(ifelse(traits$Batch=="pilot",1,0))
traits$Run1<- as.numeric(ifelse(traits$Batch=="run1",1,0))
traits$Run2<- as.numeric(ifelse(traits$Batch=="run2",1,0))
traits$yr2015<- as.numeric(ifelse(traits$Year=="2015",1,0))
traits$yr2017<- as.numeric(ifelse(traits$Year=="2017",1,0))
traits$yr2018<- as.numeric(ifelse(traits$Year=="2018",1,0))

traits<- traits[,-(1:2)] 




A=adjacency(t(wgcnadata),type="signed")
#-----Calculate whole network connectivity
k=as.numeric(apply(A,2,sum))-1
#-----Standardized connectivity
Z.k=scale(k)
thresholdZ.k=-2.5 
outlierColor=ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
#-----Convert traits to colors
traitColors=data.frame(numbers2colors(traits,signed=FALSE))
dimnames(traitColors)[[2]]=paste(names(traits))
datColors=data.frame(outlier=outlierColor,traitColors)

#-----Plot the sample dendrogram
plotDendroAndColors(sampleTree,groupLabels=names(datColors),
                    colors=datColors,main="Sample dendrogram and trait heatmap")
```

## Effect of Batch Correction

```{r batch correction}
mat<- limma::removeBatchEffect(vsd_data, key_brain$Batch)
p <- pca(mat, metadata = key_brain)
biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", title="PCA removeBatchEffect(Batch)")
eigencorplot(p, metavars = c("Batch","Year", "Status"))

```


The analysis above also suggests PFT1_TNA_run2 is an outlier, based on the connectivity to the remainder of the analysis. PFT1_TNA_run2 is still an outlier when I exclude it from the smaller dataset that exludes the pilot samples (not shown). Therefore, I have excuded it below. 


```{r WGCNA analysis, eval=FALSE, echo=FALSE}
datExpr0<- as.data.frame(t(vsd_data))
#write.csv(datExpr0, file="wholebrain_vsd_nobatchrm.csv")
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK


powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")

sft<- sft$fitIndices
sft$dataset<- "all"
```



What do the data look like without the pilot samples (Horton et al 2020) and batch correction? Here I rerun the same analyses as above but excluding the batch correction and without the pilot samples. 


<br>

## Removing the pilot data 


```{r removing pilot data}
outliers=c("PFT2_POM_run1", "PFT1_TNA_run2")
key_brain<- key_behav[key_behav$Tissue!="GON",]
key_brain<- key_brain[key_brain$Tissue!="PIT",]
key_brain<- key_brain[key_brain$Batch!="pilot",]
key_brain<- key_brain[!key_brain$X %in% outliers,]
rownames(key_brain)<- key_brain$X
#
brain_data<- data[, colnames(data) %in% key_brain$X]
###filter out lowly expressed genes
#
##remove genes with less than 20 reads
brain_data$avg_count<- apply(brain_data, 1, mean)
brain_data<- brain_data[brain_data$avg_count>20,]
brain_data$avg_count<-NULL



dd<- DESeqDataSetFromMatrix(countData=brain_data, colData=key_brain, design= ~ Tissue)
dd<- DESeq(dd)
dd<- dd[which(mcols(dd)$betaConv),]

vsd_data<- getVarianceStabilizedData(dd)

p <- pca(vsd_data, metadata = key_brain)
biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", title="PCA brain (pilot samples removed)")
##eigencorplot(p, metavars = c("Batch","Year", "Status", "Tissue"))

```



### Batch Effect Correction

```{r}
mat2<- limma::removeBatchEffect(vsd_data, key_brain$Batch)
p <- pca(mat2, metadata = key_brain)
biplot(p, lab=NULL, colby="Tissue", shape="Batch", legendPosition="right", title="PCA removeBatchEffect(Batch)")
eigencorplot(p, metavars = c("Batch","Year", "Status", "Tissue"))

```

The PCA plot without batch correction still shows that tissues (and different batches) are clustered more closely. Perhaps in part this is still because batches are not evenly distributed across tissues. 

Going forward with the WGCNA analysis on all brain samples, I will exclude pilot data and I will not conduct batch correction. However, I will include a batch variable in the trait-module correlation matrix. 


<br><br>

# WGCNA Analysis

Using the dataset without the pilot data and the two outliers `PFT2_POM_run1` and `PFT1_TNA_run2`, I will now commence the main co-expression analysis.

```{r , echo=TRUE}
datExpr0<- as.data.frame(t(vsd_data))
#write.csv(datExpr0, file="wholebrain_vsd_nobatchrm.csv")
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
```

<br>




## Soft Threshold Selection 



```{r, eval=FALSE, echo=FALSE}
#effect of data type on scale free topology
datasets<- list(all_batchcor=t(mat),pilotexc_batchcor=t(mat2),pilotexc=datExpr0)
sft2<- list()
for(i in names(datasets)){
  powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))
  dat<- datasets[[i]]
  res<- pickSoftThreshold(dat, powerVector=powers, verbose=0, networkType="signed")
  res<- res$fitIndices
  res$dataset<- i
  sft2[[i]]<- res
}


sft3<- do.call("rbind", sft2)
sft3<- rbind(sft3,sft)
sft3$cols<- ifelse(sft3$dataset=="all","red",ifelse(sft3$dataset=="all_batchcor","darkred",ifelse(sft3$dataset=="pilotexc","blue","darkblue")))

par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft3[,1], -sign(sft3[,3])*sft3[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"),col=sft3$cols);
text(sft3[,1], -sign(sft3[,3])*sft3[,2],
     labels=powers,cex=cex1,col=sft3$cols);
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
legend('topright', legend = levels(sft3$cols), col = 1:3, cex = 0.8, pch = 1)
# Mean connectivity as a function of the soft-thresholding power
plot(sft3[,1], sft3[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft3[,1], sft3[,5], labels=powers, cex=cex1,col=sft3$cols)
softPower=20
```


```{r soft threshold, fig.width=10, fig.height=5}
powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(datExpr0, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=20
```

Seems like there is no strong effect on Scale Free Topology The soft-threshold power I have selected here is `r softPower`, after which there is little improvement in the Scale free topology fit. 

Going forward I will just use the pilot batch free data to be safe, given this was the stronger of the batch effects.

<br>

## Adjacency and Topological Overlap matrices

The adjacency matrix and Topological Overlap was made on an external server to save my PC some RAMs. 

```{r adjacency matrix, eval=FALSE, echo=TRUE}

softPower=20

#datExpr0<- read.csv("../WGCNA_results/all_brain/wholebrain_vsd_nobatchrm.csv")
#rownames(datExpr0)<- datExpr0$X
#datExpr0$X<- NULL

adjacency<- adjacency(datExpr0, power = softPower, type="signed")
TOM<- TOMsimilarity(adjacency, TOMType="signed")
#dissTOM<- 1-TOM

save(adjacency, TOM, file="../WGCNA_results/all_brain/wholebrain_network2023.RData")
```

<br>

## Identify co-expression modules

The first step is to identify modules of genes with similar gene expression. Basically, the tool creates a hierarchical clustering of the topological dissimilarity between genes.

```{r calculate modules, echo=TRUE, message=FALSE}
#write.csv(datExpr0,file="../WGCNA_results/all_brain/wholebrain_vsd_nobatchrm.csv")
#for the rmarkdown knit this data is already loaded above.
#datExpr0<- read.csv("../WGCNA_results/all_brain/wholebrain_vsd_nobatchrm.csv")
#rownames(datExpr0)<- datExpr0$X
#datExpr0$X<- NULL


load("../WGCNA_results/all_brain/wholebrain_network2023.RData")
dissTOM<- 1-TOM

geneTree= flashClust(as.dist(dissTOM), method="average")

#plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
minModuleSize<-30 
dynamicMods<-cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
#table(dynamicMods)

dynamicColors= labels2colors(dynamicMods)


plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")
```


Now we try to merge some of these modules that are particularly similar in expression based on a similarity threshold.


```{r, echo=TRUE}
#-----Merge modules whose expression profiles are very similar
MEList= moduleEigengenes(datExpr0, colors= dynamicColors)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")


#plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.30 # i.e. merge modules with an r2 > 0.90. This is stringent, could relax to reduce number of modules and increase module size.
#abline(h=MEDissThres, col="red")
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors=merge$colors
mergedMEs= merge$newMEs


plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)


moduleColors= mergedColors
colorOrder= c("grey", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs

```

<br>

## Module-trait correlation

Correlate the eigenvector of each of the `r ncol(MEs)` co-expression modules with brain regions, individual and batch, as well as our interest variables (mean testosterone, status, and social network strength) 

```{r trait correlation, echo=TRUE, fig.width=20, fig.height=12}
datTraits<- key_brain
all.equal(rownames(datExpr0), rownames(datTraits))

datTraits$Batch<- ifelse(grepl("run1",datTraits$sampleID), 1,0)
datTraits$Year<- as.numeric(as.factor(datTraits$Year))
datTraits$Ai<- ifelse(grepl("AI", datTraits$sampleID), 1,0)
datTraits$TnA<- ifelse(grepl("TNA", datTraits$sampleID), 1,0)
datTraits$BSTm<- ifelse(grepl("BST", datTraits$sampleID), 1,0)
datTraits$ICO<- ifelse(grepl("ICO", datTraits$sampleID), 1,0)
datTraits$GCT<- ifelse(grepl("GCT", datTraits$sampleID), 1,0)
datTraits$LS<- ifelse(grepl("LS", datTraits$sampleID), 1,0)
datTraits$POM<- ifelse(grepl("POM", datTraits$sampleID), 1,0)
datTraits$VMH<- ifelse(grepl("VMH", datTraits$sampleID), 1,0)
datTraits$AH<- ifelse(grepl("AH", datTraits$sampleID), 1,0)
datTraits$PVN<- ifelse(grepl("PVN", datTraits$sampleID), 1,0)
datTraits$Bird<- as.numeric(as.factor(datTraits$sampleID))

datTraits$Status2<- as.numeric(ifelse(datTraits$Status=="territorial",1,0))


datTraits<- subset(datTraits, select=c("Bird","Batch","Year","Status2", "mean_T","strength.all_study","VMH","AH","PVN","POM","ICO","GCT","Ai","TnA","LS", "BSTm"))
names(datTraits)[names(datTraits)=="Status2"] <- "Status"



#-----Define numbers of genes and samples
nGenes = ncol(datExpr0);
nSamples = nrow(datExpr0);
#-----Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

#-----Correlations of genes with eigengenes
moduleGeneCor=cor(MEs,datExpr0)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);

moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

#---------------------Module-trait heatmap


textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(7, 9, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in whole brain"))
```

<br>

```{r}

knitr::kable(table(moduleColors), caption = paste("Number of genes per co-expression module")) %>% kable_styling()
```

See the data portion of this repository to see the the module membership and gene-significance results. 

```{r module memberships, echo=TRUE}
datME<- moduleEigengenes(datExpr0,mergedColors)$eigengenes
datKME<- signedKME(datExpr0, datME, outputColumnName="MM.") #use the "signed eigennode connectivity" or module membership

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples)) # Calculate module membership P-values
datKME$gene<- rownames(datKME)
MMPvalue$gene<- rownames(MMPvalue)
genes=names(datExpr0)
geneInfo0 <- data.frame(gene=genes,moduleColor=moduleColors)
geneInfo0 <- merge(geneInfo0, genes_key, by="gene", all.x=TRUE)
color<- merge(geneInfo0, datKME, by="gene") #these are from your original WGCNA analysis 
#head(color)
write.csv(as.data.frame(color), file = paste("../WGCNA_results/all_brain/wholebrain_results_ModuleMembership.csv", sep="_"), row.names = FALSE)
MMPvalue<- merge(geneInfo0, MMPvalue, by="gene")
write.csv(MMPvalue, file=paste("../WGCNA_results/all_brain/wholebrain_results_ModuleMembership_P-value.csv", sep="_"), row.names = FALSE)


#### gene-significance with traits of interest.
trait = as.data.frame(datTraits$Status) #change here for traits of interest
names(trait) = "status" #change here for traits of interest 
modNames = substring(names(MEs), 3)
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS<- cbind(geneTraitSignificance,GSPvalue)

trait = as.data.frame(datTraits$mean_T)
names(trait)= "mean_T"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS2<- cbind(geneTraitSignificance,GSPvalue)


trait = as.data.frame(datTraits$strength.all_study)
names(trait)= "strength"
geneTraitSignificance = as.data.frame(cor(datExpr0, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(trait), sep="")
names(GSPvalue) = paste("p.GS.", names(trait), sep="")
GS3<- cbind(geneTraitSignificance,GSPvalue)

GS$gene<- rownames(GS)
GS<- cbind(GS,GS2, GS3)
GS<- merge(geneInfo0,GS, by="gene")


write.csv(GS, file="../WGCNA_results/all_brain/wholebrain_results_GeneSignificance.csv", row.names = FALSE)
```

<br>

## intermodule correlations

Given the network type used, all genes in a module can only go in the same direction. This means that another module may represent genes that are downregulated by the upregulation of genes in another module (or vice-versa).

```{r intermodule correlations, fig.width=10, fig.height=10, echo=TRUE}

# Specify colors
colz<- gsub("ME","",colnames(MEs))
names(colz)<- colnames(MEs)
ann_colors = list(module=colz)

annotation_col<- data.frame(row.names=colnames(MEs), module=colnames(MEs))


correlation<- cor(MEs)
pheatmap(correlation, annotation_col = annotation_col, annotation_colors = ann_colors, annotation_legend=FALSE, legend_breaks = c(-1,-0.5,0,0.5, 1,1), 
main="module eigengene correlation in whole brain", legend_labels = c("-1", "-0.5", "0", "0.5","1","correlation\n\n"))
```


# Interesting Modules

There are three modules that appear to be associated with our traits of interest. Let's explore these further. Because the module-trait correlation procedure cannot account for tissues taken from the same individual, I will test to see if these relationships still hold when accounting for this in a linear mixed model. 



```{r, echo=TRUE}
#write.csv(MEs, file="../WGCNA_results/all_brain/ModuleEigengenes.csv")
#color<- read.csv("../WGCNA_results/all_brain/wholebrain_results_ModuleMembership.csv")
#MEs<- read.csv("../WGCNA_results/all_brain/ModuleEigengenes.csv")
#rownames(MEs)<- MEs$X
#MEs$X<- NULL

#merge module eigengenes with trait matrix.
mes<- MEs
mes$sampleID <- rownames(mes)
mes<- merge(key_brain, mes, by="sampleID")
mes$Year<- as.factor(mes$Year)
mes$Batch<- as.factor(mes$Batch)
mes$Tissue<- as.factor(mes$Tissue)
mes$Tissue<- factor(mes$Tissue, levels=c("VMH","AH","PVN","POM","ICO","GCT","AI","TNA","LS","BSTm"))


```

### darkturquoise module

This module is potentially associated with social status.

```{r darkturquoise, echo=TRUE}
whichModule="darkturquoise"
#m1 <- lme(MEdarkturquoise~Batch + Tissue + Status,random=~ 1|Harvest_ID,data=mes)
#anova(m1)

#Test 3 models 
m0<- lm(MEdarkturquoise ~ 1, data=mes)

m01<- lm(MEdarkturquoise ~ Batch, data=mes)
m01.aov<- Anova(m01, type=2)

m02<- lm(MEdarkturquoise ~ Batch + Tissue, data=mes)
m02.aov<- Anova(m02, type=2)
m02.vif<- sum(vif(m02)[,1])
#we're scaling Status because unscaled data strongly inflates VIF while the scale data doesn't change our P-values. 
m1<- lm(MEdarkturquoise~ Batch + Tissue + Status,data=mes)
m1.aov<- Anova(m1, type=2)
m1.vif<- sum(vif(m1)[,1])
m1.aov

m2<- lm(MEdarkturquoise~ Batch + Tissue * Status,data=mes,contrasts=list(Tissue=contr.sum, Status=contr.sum))
m2.aov<- Anova(m2, type=3)
m2.vif<- sum(vif(m2)[,1])
m2.aov
summary(m2)


m3<- lm(MEdarkturquoise~ Tissue + Status + Tissue:Status,data=mes,contrasts=list(Tissue=contr.sum, Status=contr.sum))
m3.aov<- Anova(m3, type=3)
m3.vif<- sum(vif(m3)[,1])
m3.aov
summary(m3)

m4<- lm(MEdarkturquoise~ Tissue + Status,data=mes)
m4.aov<- Anova(m4, type=2)
m4.vif<- sum(vif(m4)[,1])
m4.aov

models<- c("~ 1", "~ Batch", "~ Batch + Tissue","~ Batch + Tissue + Status" , "~ Batch + Tissue + Status + Tissue:Status","~ Tissue + Status + Tissue:Status", "~ Tissue + Status")
aic=signif(c(AIC(m0),AIC(m01),AIC(m02),AIC(m1),AIC(m2),AIC(m3),AIC(m4)),4)
deltaAIC<- signif(c(NA,aic[1]-aic[2],aic[1]-aic[3], aic[1]-aic[4],aic[1]-aic[5],aic[1]-aic[6],aic[1]-aic[7]),3) 

batch_p<- signif(c(NA, m01.aov$'Pr(>F)'[1],m02.aov$'Pr(>F)'[1],m1.aov$'Pr(>F)'[1],m2.aov$'Pr(>F)'[2],NA,NA),2)

e_p<- signif(c(NA, NA,NA,m1.aov$'Pr(>F)'[3],m2.aov$
'Pr(>F)'[3],m3.aov$
'Pr(>F)'[2],m4.aov$'Pr(>F)'[2]),2) 
sumVIF<- round(c(NA,NA,m02.vif, m1.vif,m2.vif, m3.vif, m4.vif),0)

ms<- data.frame(models,aic, deltaAIC,batch_p,e_p, sumVIF)
ms<- ggtexttable(ms,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL)

m4.aov<- cbind(m4.aov, c(eta_squared(m4.aov)$Eta2_partial,NA))
colnames(m4.aov)[5]<- "eta^2"

res<- as.data.frame(signif(m4.aov,2))


res<- ggtexttable(res,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=rownames(res)) %>% tab_add_title(text = paste0(whichModule,models[7]), size=6, padding = unit(0.1, "line"))


#plot the module eigengene against our traits of interest
a<- ggplot() + geom_point(data=mes, aes(x=Tissue, y=MEdarkturquoise, color=status), position=position_dodge(width=0.7)) + geom_boxplot(data=mes, aes(x=Tissue, y=MEdarkturquoise, color=status), fill=NA, outlier.colour = NA) + peri_figure + labs(title="darkturquoise module eigengene vs status") + scale_colour_manual(values=status_cols2) + theme(legend.position="none")
a

#g<- ggarrange(a,res, labels=LETTERS[1:2], ncol=2)
#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png", height=100, width=80, units="mm", bg="white")


#a<- ggplot() + geom_point(data=mes, aes(x=Tissue, y=MEdarkturquoise, color=status), position=position_dodge(width=0.7),size=0.5) + geom_boxplot(data=mes, aes(x=Tissue, y=MEdarkturquoise, color=status), fill=NA, outlier.colour = NA, linewidth=0.2) + peri_figure + labs(title="darkturquoise module eigengene vs status") + scale_colour_manual(values=status_cols2) + theme(legend.position="none", axis.text.x=element_text(angle=90))
#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_ME.pdf"),plot = a, device="pdf", height=38, width=45, units="mm", bg="white")

```

Let's now plot the top hub gene. This gene is the one with the highest module membership score. UBA52 has a module membership score ~0.9

```{r}
gonec<- plotCounts(dd, gene="UBA52", intgroup=c("Status", "Tissue"), returnData=TRUE)
c<- ggplot(gonec, aes(x=Tissue, y=count, colour=Status)) + geom_boxplot(fill=NA, outlier.colour = NA) + geom_point(size=2, pch=19, position=dodge)  + labs(title="UBA52, darkturquoise hub gene",x="Status", y="Normalised Counts") + scale_colour_manual(values=status_cols2) +  peri_figure + theme(legend.position = "none")
c


```



<br>

```{r darkturquoise go}
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = color$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/all_brain/",whichModule, "GO_BP.csv", sep="_"))

go_table<- as.data.frame(ego@result)
go_table<- go_table[1:10,c("ID","Description","GeneRatio","pvalue","p.adjust")]
go_table<- go_table[!is.na(go_table$ID),]
go_table$pvalue<- signif(go_table$pvalue,2)
go_table$p.adjust<- signif(go_table$p.adjust,2)

go_table<- ggtexttable(go_table,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL) %>% tab_add_title(text = paste0("BP GO terms enriched in ", whichModule," module"), size=6, padding = unit(0.1, "line"))
 



ego2<- as.data.frame(ego@result)
ego2<- ego2[which(ego2$p.adjust<0.05),]
simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

terms<- reducedTerms %>% group_by(parentTerm) %>% summarize(n_children=n())
c<- ggplot(terms, aes(x=parentTerm, y=n_children)) + geom_bar(stat="identity", fill=whichModule, color="darkslategray4", linewidth=0.2) + coord_flip() + peri_figure_supp + labs(x="", y="No. Terms after FDR correction") + scale_y_continuous(expand=c(0,0), breaks=c(0,2,4,6,8,10))
c


g<- ggarrange(ggarrange(a,ms, widths=c(0.6,0.5), labels=c("A","B"),ncol=2),ggarrange(res,c,labels=c("C","D"), ncol=2, widths = c(0.5,1)), nrow=2)
ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png", height=120, width=200, units="mm", bg="white")
ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.pdf"),plot = g, device="pdf",height=120, width=200, units="mm", bg="white")


#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_GO.pdf"),plot = c, device="pdf", height=30, width=90, units="mm")
```



### paleturquoise

This module is potentially associated with status.

```{r pale turquoise}
whichModule="paleturquoise"
#hd <- lme(MEpaleturquoise~Batch + Tissue + Status,random=~1|Harvest_ID,data=mes)
#anova(hd)
#plot(hd)

m0<- lm(MEpaleturquoise ~ 1, data=mes)

m01<- lm(MEpaleturquoise ~ Batch, data=mes)
m01.aov<- Anova(m01, type=2)

m02<- lm(MEpaleturquoise ~ Batch + Tissue, data=mes)
m02.aov<- Anova(m02, type=2)
m02.vif<- sum(vif(m02)[,1])
#we're scaling Status because unscaled data strongly inflates VIF while the scale data doesn't change our P-values. 
m1<- lm(MEpaleturquoise~ Batch + Tissue + Status,data=mes)
m1.aov<- Anova(m1, type=2)
m1.vif<- sum(vif(m1)[,1])
m1.aov

m2<- lm(MEpaleturquoise~ Batch + Tissue * Status,data=mes,contrasts=list(Tissue=contr.sum, Status=contr.sum))
m2.aov<- Anova(m2, type=3)
m2.vif<- sum(vif(m2)[,1])
m2.aov
summary(m2)

m3<- lm(MEpaleturquoise~ Tissue + Status + Tissue:Status,data=mes,contrasts=list(Tissue=contr.sum, Status=contr.sum))
m3.aov<- Anova(m3, type=3)
m3.vif<- sum(vif(m3)[,1])
m3.aov
summary(m3)

m4<- lm(MEpaleturquoise~ Tissue + Status,data=mes)
m4.aov<- Anova(m4, type=2)
m4.vif<- sum(vif(m4)[,1])
m4.aov

models<- c("~ 1", "~ Batch", "~ Batch + Tissue","~ Batch + Tissue + Status" , "~ Batch + Tissue + Status + Tissue:Status","~ Tissue + Status + Tissue:Status", "~ Tissue + Status")
aic=signif(c(AIC(m0),AIC(m01),AIC(m02),AIC(m1),AIC(m2),AIC(m3),AIC(m4)),4)
deltaAIC<- signif(c(NA,aic[1]-aic[2],aic[1]-aic[3], aic[1]-aic[4],aic[1]-aic[5],aic[1]-aic[6],aic[1]-aic[7]),3) 

batch_p<- signif(c(NA, m01.aov$'Pr(>F)'[1],m02.aov$'Pr(>F)'[1],m1.aov$'Pr(>F)'[1],m2.aov$'Pr(>F)'[2],NA,NA),2)

e_p<- signif(c(NA, NA,NA,m1.aov$'Pr(>F)'[3],m2.aov$
'Pr(>F)'[3],m3.aov$
'Pr(>F)'[2],m4.aov$'Pr(>F)'[2]),2) 
sumVIF<- round(c(NA,NA,m02.vif, m1.vif,m2.vif, m3.vif, m4.vif),0)

ms<- data.frame(models,aic, deltaAIC,batch_p,e_p, sumVIF)
ms<- ggtexttable(ms,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL)


m1.aov<- cbind(m1.aov, c(eta_squared(m1.aov)$Eta2_partial,NA))
colnames(m1.aov)[5]<- "eta^2"

res<- as.data.frame(signif(m1.aov,2))

res<- ggtexttable(res,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=rownames(res)) %>% tab_add_title(text = paste0(whichModule,models[7]), size=6, padding = unit(0.1, "line"))

#plot the module eigengene against our traits of interest
a<- ggplot() + geom_point(data=mes, aes(x=Tissue, y=MEpaleturquoise, color=status), position=position_dodge(width=0.7)) + geom_boxplot(data=mes, aes(x=Tissue, y=MEpaleturquoise, color=status), fill=NA, outlier.colour = NA) + peri_figure + labs(title=paste0(whichModule," module eigengene vs status")) + scale_colour_manual(values=status_cols2) + theme(legend.position="none")
a

#g<- ggarrange(a,res, labels=LETTERS[1:2], nrow=2)

#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png", height=100, width=80, units="mm", bg="white")
#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.pdf"),plot = g, device="pdf", height=110, width=110, units="mm", bg="white")

```

The top hub gene for this module is KCTD5 with a MM score of ~0.95
```{r}
goneb<- plotCounts(dd, gene="KCTD5", intgroup=c("Status", "Tissue"), returnData=TRUE)
b<-ggplot(goneb, aes(x=Tissue, y=count, colour=Status)) + geom_boxplot(fill=NA, outlier.colour = NA) + geom_point(size=2, pch=19, position=dodge)  + labs(title="KCTD5, darkturquoise hub gene",x="Status", y="Normalised Counts") + scale_colour_manual(values=status_cols2) +  peri_theme
b
```



```{r, eval=FALSE}
whichModule="paleturquoise"
nTop<-30 # I use all the genes in the module, but could limit to top n genes based on MM


#extract the expression of the top 30 genes and sort them based on module membership. 
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


verboseScatterplot(abs(module_genes[, modcol]),
abs(GS[GS$moduleColor==whichModule, "GS.status"]),
xlab = paste("Module Membership in", whichModule, "module"),
ylab = "Gene significance for status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = whichModule)

sorted=color$gene[order(color[,modcol],decreasing=T)]
hubs=sorted[1:nTop]
hubs=datExpr0[,match(hubs, colnames(datExpr0))]



### Sort individual data based on the trait value
expDesign<- data.frame(row.names=rownames(key_brain), mean_T=key_brain[,"mean_T"], Status=key_brain[,"Status"])
expDesign<- expDesign[order(expDesign$Status),]
ann_cols<- list(Status=c(territorial="#414042",floater="#E54849"))
hubs<- hubs[match(rownames(expDesign), rownames(hubs)), ]

#original heatmap  
pheatmap(hubs,scale="column", cluster_rows = FALSE,cluster_cols = FALSE,show_rownames = TRUE, show_colnames = TRUE,border_color=NA,  main=paste(whichModule,"module in brain"), annotation_row=expDesign, annotation_colors=ann_cols)

```

```{r GO paleturqoise}
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = color$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/all_brain/",whichModule, "GO_BP.csv", sep="_"))

go_table<- as.data.frame(ego@result)
go_table<- go_table[1:10,c("ID","Description","GeneRatio","pvalue","p.adjust")]
go_table<- go_table[!is.na(go_table$ID),]
go_table$pvalue<- signif(go_table$pvalue,2)
go_table$p.adjust<- signif(go_table$p.adjust,2)

go_table<- ggtexttable(go_table,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL) %>% tab_add_title(text = paste0("BP GO terms enriched in ", whichModule," module"), size=6, padding = unit(0.1, "line"))
 

g<- ggarrange(ggarrange(a,ms, widths=c(0.6,0.5), labels=c("A","B"),ncol=2),ggarrange(res,go_table,labels=c("C","D"), ncol=2, widths = c(0.5,1)), nrow=2)

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png",height=120, width=200, units="mm", bg="white")

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.pdf"),plot = g, device="pdf", height=120, width=200, units="mm", bg="white")
```

<br>

### honeydew1 module

This module is potentially associated with social network strength.
Don't need batch here because it wasn't associated with this module. 

```{r honeydew1}
whichModule="honeydew1"
#hd <- lme(MEhoneydew1 ~ Batch + Tissue + strength.all_study,random=~1|Harvest_ID,data=mes)
#anova(hd)
#plot(hd)

m0<- lm(MEhoneydew1 ~ 1, data=mes)

m01<- lm(MEhoneydew1 ~ Year, data=mes)
m01.aov<- Anova(m01, type=2)

m02<- lm(MEhoneydew1 ~ Year + Tissue, data=mes)
m02.aov<- Anova(m02, type=2)
m02.vif<- sum(vif(m02)[,1])
#we're scaling strength because unscaled data strongly inflates VIF while the scale data doesn't change our P-values. 
m1<- lm(MEhoneydew1~ Year + Tissue + scale(strength.all_study),data=mes)
m1.aov<- Anova(m1, type=2)
m1.vif<- sum(vif(m1)[,1])
m1.aov
m2<- lm(MEhoneydew1~ Year + Tissue * scale(strength.all_study),data=mes)
m2.aov<- Anova(m2, type=3)
m2.vif<- sum(vif(m2)[,1])
m2.aov
summary(m2)

m3<- lm(MEhoneydew1~ Tissue + scale(strength.all_study) + Tissue:scale(strength.all_study),data=mes)
m3.aov<- Anova(m3, type=3)
m3.vif<- sum(vif(m3)[,1])
m3.aov
summary(m3)

m4<- lm(MEhoneydew1~ Tissue + scale(strength.all_study),data=mes)
m4.aov<- Anova(m4, type=2)
m4.vif<- sum(vif(m4)[,1])
m4.aov


models<- c("~ 1", "~ Year", "~ Year + Tissue","~ Year + Tissue + Strength" , "~ Year + Tissue + Strength + Tissue:Strength","~ Tissue + Strength + Tissue:Strength", "~ Tissue + Strength")
aic=signif(c(AIC(m0),AIC(m01),AIC(m02),AIC(m1),AIC(m2),AIC(m3),AIC(m4)),4)
deltaAIC<- signif(c(NA,aic[1]-aic[2],aic[1]-aic[3], aic[1]-aic[4],aic[1]-aic[5],aic[1]-aic[6],aic[1]-aic[7]),3) 

batch_p<- signif(c(NA, m01.aov$'Pr(>F)'[1],m02.aov$'Pr(>F)'[1],m1.aov$'Pr(>F)'[1],m2.aov$'Pr(>F)'[2],NA,NA),2)

e_p<- signif(c(NA, NA,NA,m1.aov$'Pr(>F)'[3],m2.aov$
'Pr(>F)'[3],m3.aov$
'Pr(>F)'[2],m4.aov$'Pr(>F)'[2]),2) 
sumVIF<- round(c(NA,NA,m02.vif, m1.vif,m2.vif, m3.vif, m4.vif),0)

ms<- data.frame(models,aic, deltaAIC,batch_p,e_p, sumVIF)
ms<- ggtexttable(ms,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL)


m4.aov<- cbind(m4.aov, c(eta_squared(m4.aov)$Eta2_partial,NA))
colnames(m4.aov)[5]<- "eta^2"

res<- as.data.frame(signif(m4.aov,2))

res<- ggtexttable(res,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=rownames(res)) %>% tab_add_title(text = paste0(whichModule," ~ Tissue + Strength"), size=6, padding = unit(0.1, "line"))


#plot the module eigengene against our traits of interest
a<- ggplot(data=mes, aes(x=strength.all_study, y=MEhoneydew1)) + geom_point(pch=21, fill="honeydew", colour="honeydew4", size=2) + peri_figure + facet_wrap(~ Tissue, ncol=5) + labs(title="honeydew1 module eigengene vs strength") + geom_smooth(method="lm", alpha=0.3, colour="honeydew4",se=FALSE) + theme(legend.position="none",strip.text.x = element_text(size = 6, margin=margin(1,1,1,1,"pt")))
a



```


```{r}
gonea<- plotCounts(dd, gene="PER3", intgroup=c("strength.all_study", "Tissue"), returnData=TRUE)
a<- ggplot(gonea, aes(x=strength.all_study, y=count)) + geom_point(size=2, pch=21 ,fill="honeydew1",color="black") + labs(title="PER3, honeydew1 hub gene",x="Strength", y="Normalised Counts") + facet_wrap( ~ Tissue, ncol=5) + peri_theme + geom_smooth(method="lm", alpha=0.10, colour="honeydew4", fill="honeydew3")
a
```

Not significant after controlling for batch, tissue and indivdual as a random effect. 


<br>

```{r honeydew1 go}
whichModule="honeydew1"
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = color$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/all_brain/",whichModule, "GO_BP.csv", sep="_"))

go_table<- as.data.frame(ego@result)
go_table<- go_table[1:10,c("ID","Description","GeneRatio","pvalue","p.adjust")]
go_table<- go_table[!is.na(go_table$ID),]
go_table$pvalue<- signif(go_table$pvalue,2)
go_table$p.adjust<- signif(go_table$p.adjust,2)

go_table<- ggtexttable(go_table,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL) %>% tab_add_title(text = paste0("BP GO terms enriched in ", whichModule," module"), size=6, padding = unit(0.1, "line"))
 
g<- ggarrange(ggarrange(a,ms, widths=c(0.6,0.5), labels=c("A","B"),ncol=2),ggarrange(res,go_table,labels=c("C","D"), ncol=2, widths = c(0.5,1)), nrow=2)

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png",height=120, width=200, units="mm", bg="white")

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.pdf"),plot = g, device="pdf", height=120, width=200, units="mm", bg="white")
```



### darkorange2


```{r}
whichModule="darkorange2"
#hd <- lme(MEdarkorange2~Batch + Tissue + strength.all_study,random=~1|Harvest_ID,data=mes)
#summary(hd)
#anova(hd)
#plot(hd)


m0<- lm(MEdarkorange2 ~ 1, data=mes)

m01<- lm(MEdarkorange2 ~ Year, data=mes)
m01.aov<- Anova(m01, type=2)

m02<- lm(MEdarkorange2 ~ Year + Tissue, data=mes)
m02.aov<- Anova(m02, type=2)
m02.vif<- sum(vif(m02)[,1])
#we're scaling strength because unscaled data strongly inflates VIF while the scale data doesn't change our P-values. 
m1<- lm(MEdarkorange2~ Year + Tissue + scale(strength.all_study),data=mes)
m1.aov<- Anova(m1, type=2)
m1.vif<- sum(vif(m1)[,1])
m1.aov
m2<- lm(MEdarkorange2~ Year + Tissue * scale(strength.all_study),data=mes)
m2.aov<- Anova(m2, type=3)
m2.vif<- sum(vif(m2)[,1])
m2.aov
summary(m2)

m3<- lm(MEdarkorange2~ Tissue + scale(strength.all_study) + Tissue:scale(strength.all_study),data=mes)
m3.aov<- Anova(m3, type=3)
m3.vif<- sum(vif(m3)[,1])
summary(m3)

m4<- lm(MEdarkorange2~ Tissue + scale(strength.all_study),data=mes)
m4.aov<- Anova(m4, type=2)
m4.vif<- sum(vif(m4)[,1])
m4.aov


models<- c("~ 1", "~ Year", "~ Year + Tissue","~ Year + Tissue + Strength" , "~ Year + Tissue + Strength + Tissue:Strength","~ Tissue + Strength + Tissue:Strength", "~ Tissue + Strength")
aic=signif(c(AIC(m0),AIC(m01),AIC(m02),AIC(m1),AIC(m2),AIC(m3),AIC(m4)),4)
deltaAIC<- signif(c(NA,aic[1]-aic[2],aic[1]-aic[3], aic[1]-aic[4],aic[1]-aic[5],aic[1]-aic[6],aic[1]-aic[7]),3) 

batch_p<- signif(c(NA, m01.aov$'Pr(>F)'[1],m02.aov$'Pr(>F)'[1],m1.aov$'Pr(>F)'[1],m2.aov$'Pr(>F)'[2],NA,NA),2)

e_p<- signif(c(NA, NA,NA,m1.aov$'Pr(>F)'[3],m2.aov$
'Pr(>F)'[3],m3.aov$
'Pr(>F)'[2],m4.aov$'Pr(>F)'[2]),2) 
sumVIF<- round(c(NA,NA,m02.vif, m1.vif,m2.vif, m3.vif, m4.vif),0)

ms<- data.frame(models,aic, deltaAIC,batch_p,e_p, sumVIF)
ms<- ggtexttable(ms,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL)

eta_squared(m1.aov)
m4.aov<- cbind(m4.aov, c(eta_squared(m4.aov)$Eta2_partial,NA))
colnames(m4.aov)[5]<- "eta^2"

res<- as.data.frame(signif(m4.aov,2))


res<- ggtexttable(res,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=rownames(res)) %>% tab_add_title(text = paste0(whichModule," ~ Tissue + Strength"), size=6, padding = unit(0.1, "line"))



a<- ggplot(data=mes, aes(x=strength.all_study, y=MEdarkorange2)) + geom_point(pch=21,fill="darkorange2",colour="grey20", size=2)  + peri_figure + facet_wrap(~ Tissue, ncol=5) + labs(title="darkorange2 module eigengene vs strength") + geom_smooth(method="lm", alpha=0.1, colour="darkorange4", se=FALSE) + theme(legend.position="none",strip.text.x = element_text(size = 6, margin=margin(1,1,1,1,"pt")))
a

#g<- ggarrange(a,res, labels=LETTERS[1:2], nrow=2)

#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png", height=110, width=110, units="mm", bg="white")
a<- ggplot(data=mes, aes(x=strength.all_study, y=MEdarkorange2)) + geom_point(pch=21,fill="darkorange2",colour="darkorange4", size=1,stroke=0.2)  + peri_figure + facet_wrap(~ Tissue, ncol=5) + labs(title="darkorange2 module eigengene vs strength") + geom_smooth(method="lm", alpha=0.1, colour="darkorange4", se=FALSE,linewidth=0.2) + theme(legend.position="none",strip.text.x = element_text(size = 6, margin=margin(0,0,0,0,"pt")))
#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_ME.pdf"),plot = a, device="pdf", height=40, width=80, units="mm", bg="white")

goneb<- plotCounts(dd, gene="HSPA5", intgroup=c("strength.all_study", "Tissue"), returnData=TRUE)
b<-ggplot(goneb, aes(x=strength.all_study, y=count)) + geom_point(size=2, pch=21 ,fill="darkorange2",color="black") + labs(title="HSPA5, darkorange2 hub gene",x="Strength", y="Normalised Counts") + facet_wrap( ~ Tissue,ncol=5) + peri_theme + geom_smooth(method="lm", alpha=0.1, colour="darkorange4", fill="darkorange3") 
b
```

<br>

```{r darkorange2 go}
whichModule="darkorange2"
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = color$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()
write.csv(ego@result, file=paste("../WGCNA_results/all_brain/",whichModule, "GO_BP.csv", sep="_"))

go_table<- as.data.frame(ego@result)
go_table<- go_table[1:10,c("ID","Description","GeneRatio","pvalue","p.adjust")]
go_table<- go_table[!is.na(go_table$ID),]
go_table$pvalue<- signif(go_table$pvalue,2)
go_table$p.adjust<- signif(go_table$p.adjust,2)

go_table<- ggtexttable(go_table,theme = ttheme(base_size = 6,padding=unit(c(4,10),"pt")),rows=NULL) %>% tab_add_title(text = paste0("BP GO terms enriched in ", whichModule," module"), size=6, padding = unit(0.1, "line"))
 


ego2<- as.data.frame(ego@result)
ego2<- ego2[which(ego2$p.adjust<0.05),]
simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)
library(dplyr)
terms<- reducedTerms %>% group_by(parentTerm) %>% summarize(n_children=n())
c<- ggplot(terms, aes(x=parentTerm, y=n_children)) + geom_bar(stat="identity", fill=whichModule, color="darkorange4", linewidth=0.2) + coord_flip() + peri_figure_supp + labs(x="", y="No. Terms after FDR correction") + scale_y_continuous(expand=c(0,0))
c


g<- ggarrange(ggarrange(a,ms, widths=c(0.6,0.5), labels=c("A","B"),ncol=2),ggarrange(res,c,labels=c("C","D"), ncol=2, widths = c(0.5,1)), nrow=2)

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.png"),plot = g, device="png",height=120, width=200, units="mm", bg="white")

ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_eigengene.pdf"),plot = g, device="pdf", height=120, width=200, units="mm", bg="white")

#ggsave(filename=paste0("../WGCNA_results/all_brain/figure_",whichModule,"_GO.pdf"),plot = c, device="pdf", height=30, width=90, units="mm", bg="white")

```


### navajowhite2

This module is interesting because it's associated with many sex-steroid related genes in the hypothalamic regions.

```{r}

#hd <- lme(MEnavajowhite2~Batch + Status,random=~1|Harvest_ID,data=mes)
#summary(hd)
#anova(hd)
hd2 <- lm(MEnavajowhite2~ Batch + Tissue * Status,data=mes)
anova(hd2)

ggplot(data=mes, aes(x=Tissue, y=MEnavajowhite2, color=Status)) + geom_point(position=dodge) + geom_boxplot(fill=NA, outlier.colour = NA) + peri_theme + labs(title="navajowhite module eigengene vs social status")

whichModule="navajowhite2"

#extract the genes in the module for gene ontology analysis
modcol=paste("MM.",whichModule,sep="")
module_genes<- color[color$moduleColor==whichModule,]


```

This gene ontology analysis compared the genes in the navajowhite module against all other genes in the dataset.

```{r navajowhite}
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("BP enriched GO terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()
#write.csv(ego@result, file=paste("../WGCNA_results/all_brain/",whichModule, "GO_BP.csv", sep="_"))

ego2<- as.data.frame(ego@result$ID)
colnames(ego2)<- "ID"
ego2$p.adjust<- ego@result$p.adjust


simMatrix <- calculateSimMatrix(ego2$ID,
                                orgdb="org.Hs.eg.db",
                                ont="BP",
                                method="Rel")
scores <- setNames(-log10(ego2$p.adjust), ego2$ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Hs.eg.db")
treemapPlot(reducedTerms)

```

```{r}
for(m in unique(color$moduleColor)){
  whichModule=m
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)


write.csv(ego@result, file=paste("../WGCNA_results/HPG/",whichModule, "GO_BP.csv", sep="_"))
}

```





## GO for modules

```{r}
for(m in unique(color$moduleColor)){
  whichModule=m
module_genes<- color[color$moduleColor==whichModule,]

ego <- enricher(gene          = module_genes$gene,
                universe      = geneInfo0$gene,
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                TERM2GENE=go2gene_bp,
                TERM2NAME=go2name_bp)

knitr::kable(ego@result[1:10,], caption=paste0("TOP enriched GO BP terms in ", whichModule," module"), row.names = FALSE) %>% kable_styling()

write.csv(ego@result, file=paste("../WGCNA_results/HPG/",whichModule, "GO_BP.csv", sep="_"))
}

```

# Module Connectivity

```{r}
#subset the territorial
terr_key<- key_brain[which(key_brain$Status=="territorial"),]


#subset the expression data to only include the territorial data

terr_dat<- datExpr0[rownames(datExpr0) %in% rownames(terr_key),]
#terr_dat<- terr_dat[,order(colnames(terr_dat))]


gsg = goodSamplesGenes(terr_dat, verbose = 3)
gsg$allOK

powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(terr_dat, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=24

#terr_adj<- adjacency<- adjacency(terr_dat, power = softPower, type="signed")
#save(terr_adj, file="../WGCNA_results/all_brain/terr_adj.RData")
load("../WGCNA_results/all_brain/terr_adj.RData")
#TOM_terr<- TOMsimilarity(terr_adj, TOMType="signed")
#save(TOM_terr,file="../WGCNA_results/all_brain/terr_TOM.RData")
```

```{r}

#subset the territorial
flo_key<- key_brain[which(key_brain$Status=="floater"),]


#subset the expression data to only include the floater data

flo_dat<- datExpr0[rownames(datExpr0) %in% rownames(flo_key),]
#flo_dat<- flo_dat[,order(colnames(flo_dat))]


gsg = goodSamplesGenes(flo_dat, verbose = 3)
gsg$allOK

powers<- c(seq(1, 11, by = 1), seq(12, 30, by = 2))


sft<- pickSoftThreshold(flo_dat, powerVector=powers, verbose=0, networkType="signed")


par(mfrow = c(1,2))
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
softPower=26


#flo_adj<- adjacency(flo_dat, power = softPower, type="signed")
#save(flo_adj, file="../WGCNA_results/all_brain/flo_adj.RData")
load("../WGCNA_results/all_brain/flo_adj.RData")
#TOM_flo<- TOMsimilarity(flo_adj, TOMType="signed")
#save(TOM_flo,file="../WGCNA_results/all_brain/flo_TOM.RData")
```


```{r calculate connectivity}
#rm(list=c(adjacency,TOM,dissTOM))
color<-read.csv("../WGCNA_results/all_brain/wholebrain_results_ModuleMembership.csv")
color<- color[match(colnames(terr_dat),color$gene,),]
all.equal(color$gene, colnames(terr_dat))
all.equal(color$gene, colnames(flo_adj))

#modcon<- intramodularConnectivity(adjacency, color$moduleColor)
#modcon$gene<- rownames(modcon)
#modcon<- merge(modcon, color, by="gene")
#modcon$Status<- "total_dataset"

#modcon_flo<- intramodularConnectivity.fromExpr(flo_dat, color$moduleColor, networkType = "signed", power=26)
modcon_flo<- intramodularConnectivity(flo_adj, color$moduleColor)
modcon_flo$gene<- rownames(modcon_flo)
modcon_flo$Status<- "floater"

#modcon_terr<- intramodularConnectivity.fromExpr(terr_dat, color$moduleColor, networkType = "signed", power =24)
modcon_terr<- intramodularConnectivity(terr_adj, color$moduleColor)
modcon_terr$gene<- rownames(modcon_terr)
modcon_terr$Status<- "territorial"

modcon_status<- rbind(modcon_terr,modcon_flo)
modcon_status<- merge(modcon_status, color,by="gene")

#modcon_third<- rbind(modcon_status,modcon)

#ggplot(modcon_third[modcon_third$moduleColor=="navajowhite2",], aes(x=Status,y=kTotal)) + geom_jitter(colour="grey80", width=0.3) + geom_violin(fill=NA, outlier.colour = NA) + peri_theme


```

```{r}
library(reshape2)
means_stats<- list()
diffs<- list()
plots_total<- list()
plots_IM<- list()
plots_cor<- list()
cor_out<- list()

mwus_total<- list()
mwus_IM<- list()

pvalues_total<-  vector(mode="numeric")
pvalues_IM<-  vector(mode="numeric")
for(i in unique(color$moduleColor)){
  #i="darkturquoise"
  mod<- modcon_status[modcon_status$moduleColor==i,]
  
  #conduct mann-whitney u-test
  mwu<- wilcox.test(mod$kTotal[mod$Status=="territorial"],mod$kTotal[mod$Status=="floater"])
  mwus_total[[i]]<- mwu
  pvalues_total[i]<- mwu$p.value
  
   #conduct mann-whitney u-test kwithin
  mwu<- wilcox.test(mod$kWithin[mod$Status=="territorial"],mod$kWithin[mod$Status=="floater"])
  mwus_IM[[i]]<- mwu
  pvalues_IM[i]<- mwu$p.value

}


q_total<- p.adjust(pvalues_total, method="BH")
q_IM<- p.adjust(pvalues_IM, method="BH")

for(i in unique(color$moduleColor)){
    mod<- modcon_status[modcon_status$moduleColor==i,]
    mod2<- mod %>% group_by(Status) %>% summarise(means=mean(kTotal),medians=median(kTotal))
  mod2$module=i
  means_stats[[i]]<- mod2
  diffs[[i]]<- data.frame(module=i,mean_diff=mod2$means[2]-mod2$means[1],median_diff=mod2$medians[2]-mod2$medians[1])
  
  #kTotal Plot
  p<- ggplot() + geom_violin(data=mod,aes(x=Status,y=kTotal),fill=i) + geom_point(data=mod2, aes(x=Status, y=means), pch=21, fill="white") +geom_point(data=mod2, aes(x=Status, y=medians), pch=25, fill="white")
  p<- p + peri_figure_supp
  p<- p + labs(title=i, subtitle=paste0("diff. median connectivity (kTotal) ",signif(mod2$medians[2]-mod2$medians[1],2), "\nW=",mwus_total[[i]]$statistic,", p=",signif(mwus_total[[i]]$p.value,2),", q=",signif(q_total[i],2)))
  plots_total[[i]]<- p
  
   #kWithinPlot
  
   mod2<- mod %>% group_by(Status) %>% summarise(means=mean(kWithin),medians=median(kWithin))
   
   q<- ggplot() + geom_violin(data=mod,aes(x=Status,y=kWithin),fill=i) + geom_point(data=mod2, aes(x=Status, y=means), pch=21, fill="white") +geom_point(data=mod2, aes(x=Status, y=medians), pch=25, fill="white")
  q<- q + peri_figure_supp
  q<- q + labs(title=i, subtitle=paste0("diff. median connectivity (kWithin) ",signif(mod2$medians[2]-mod2$medians[1],2), "\nW=",mwus_IM[[i]]$statistic,", p=",signif(mwus_IM[[i]]$p.value,2),", q=",signif(q_IM[i],2)))
  plots_IM[[i]]<- q

  mod3<- dcast(mod,gene + moduleColor ~ Status, value.var = "kTotal")
  m<- lm(floater ~ territorial, data=mod3)
  rsq<- round(summary(m)$r.squared,2)
  mod3$residuals<- residuals(m)
  
    c<- ggplot(mod3, aes(x=territorial, y=floater)) + geom_point(fill=i,pch=21, size=2) + geom_smooth(method="lm", alpha=0.15, colour="black",fill="black") + peri_figure_supp + labs(title=i,subtitle=substitute(paste("R"^{2},"=",a),list(a=rsq)),x="Territorial Connectivity (kTotal)",y="Floater Connectivity (kTotal)")
  plots_cor[[i]]<- c  
  cor_out[[i]]<- mod3
  
}

#make plots
g<- ggarrange(plotlist=plots_total)
g
ggsave(filename="../WGCNA_results/all_brain/figure_kTotal_all.png",g, height=210,width=210, units="mm",bg="white", device="png")
ggsave(filename="../WGCNA_results/all_brain/figure_kTotal_all.pdf",g, height=210,width=210, units="mm",bg="white", device="pdf")

c<- ggarrange(plotlist=plots_cor)
c
ggsave(filename="../WGCNA_results/all_brain/figure_kTotal_corr.png",c, height=210,width=210, units="mm",bg="white", device="png")
cor_out<- do.call("rbind",cor_out)
write.csv(cor_out,file="../WGCNA_results/all_brain/results_kTotal_residuals.csv")

z<- ggarrange(plotlist=plots_IM)
z
ggsave(filename="../WGCNA_results/all_brain/figure_kWithin_all.png",g, height=210,width=210, units="mm",bg="white", device="png")
```

How does module size influence connectivity?

```{r}
diffs2<- do.call("rbind",diffs)
ps<- as.data.frame(cbind(pvalues_total, q))
diffs2<- cbind(diffs2,ps)
module_size<- as.data.frame(table(color$moduleColor))
colnames(module_size)<- c("module","size")
diffs2<- merge(module_size, diffs2, by="module")
s<- ggplot(diffs2, aes(x=size,y=abs(median_diff), fill=module)) + geom_point(pch=21, size=2) + scale_fill_manual(values=levels(diffs2$module)) + geom_text_repel(aes(label=module), size=geom.text.size, segment.size=0.2, hjust=-0.2) + peri_figure_supp + theme(legend.position = "none") + labs(x="module size", y="|Difference in median kTotal| (floater-territorial)")
s
ggsave(filename="../WGCNA_results/all_brain/figure_size_diffkTotal.png",s, height=100,width=100, units="mm",bg="white", device="png")
```

# Module Preservation

```{r calc module preservation, eval=FALSE}
color<- color[match(colnames(terr_dat),color$gene,),]
setLabels<-c("territorial","floater")
multiExpr<- list(territorial=list(data=terr_dat),floater=list(data=flo_dat))
multiColor<- list(territorial=color$moduleColor, floater=color$moduleColor)

mp=modulePreservation(multiExpr,multiColor, referenceNetworks=1, nPermutations=200, randomSeed=1, quickCor=0, verbose=3)

#Savetheresults 
save(mp,file="../WGCNA_results/all_brain/terr_vs_flo_modulePreservation.RData")

```

```{r}
load("../WGCNA_results/all_brain/terr_vs_flo_modulePreservation.RData")
ref=1
test=2

statsObs=cbind(mp$quality$observed[[ref]][[test]][,-1],mp$preservation$observed[[ref]][[test]][,-1])

statsZ=cbind(mp$quality$Z[[ref]][[test]][,-1],mp$preservation$Z[[ref]][[test]][,-1])

summary_out<- cbind(statsObs[,c("medianRank.pres","medianRank.qual")], signif(statsZ[,c("Zsummary.pres","Zsummary.qual")],2))


modColors=rownames(mp$preservation$observed[[ref]][[test]])
moduleSizes=mp$preservation$Z[[ref]][[test]][,1]
#leavegreyandgoldmodulesout 
plotMods=!(modColors%in%c("grey","gold")) 
#Textlabelsforpoints
text=modColors[plotMods]
#Auxiliaryconveniencevariable
plotData=cbind(mp$preservation$observed[[ref]][[test]][,2],mp$preservation$Z[[ref]][[test]][,2]) 
#Maintitlesfortheplot
mains=c("PreservationMedianrank","PreservationZsummary")
#Starttheplot sizeGrWindow(10,5); #pdf(fi="Plots/BxHLiverFemaleOnly-modulePreservation-Zsummary-medianRank.pdf",wi=10,h=5) 
par(mfrow=c(1,2)) 
par(mar=c(4.5,4.5,2.5,1)) 
for(p in 1:2){ 
  min=min(plotData[,p],na.rm=TRUE) 
  max=max(plotData[,p],na.rm=TRUE)
  #Adjustplotingrangesappropriately 
  if(p==2) 
  { 
    if(min>-max/10)min=-max/10
    ylim=c(min-0.1*(max-min),max+0.1*(max-min)) 
  }else 
    
    ylim=c(max+0.1*(max-min),min-0.1*(max-min))
    

plot(moduleSizes[plotMods],plotData[plotMods,p],col=1,bg=modColors[plotMods],pch=21, main=mains[p], cex=2.4, ylab=mains[p],xlab="Modulesize",log="x", ylim=ylim, xlim=c(10,2000),cex.lab=1.2,cex.axis=1.2,cex.main=1.4)

labelPoints(moduleSizes[plotMods],plotData[plotMods,p],text,cex=1,offs=0.08)

#ForZsummary,addthresholdlines 
  if(p==2) 
  { 
    abline(h=0) 
    abline(h=2,col="blue",lty=2)
    abline(h=10,col="darkgreen",lty=2) 
    } 
  }
```


```{r, eval=FALSE}
nSets=2
# This variable will contain the summary table
summaryTable = NULL
# Loop over all combinations of reference and tests sets
for (ref in 1:nSets) for (test in 1:nSets) if (ref!=test)
{
modules = rownames(mp$preservation$Z[[ref]][[test]]);
nMods = length(modules);
sizes = mp$preservation$Z[[ref]][[test]][, 1];
acc = matrix(NA, nMods, 3);
if (test!=4)
{
acc[match(rownames(mp$accuracy$observed[[ref]][[test]]), modules), ] =
mp$accuracy$observed[[ref]][[test]][, -1, drop = FALSE];
colnames(acc) = colnames(mp$accuracy$observed[[ref]][[test]])[-1];
accZ = mp$accuracy$Z[[ref]][[test]][, -1, drop = FALSE];
acc.log.p = mp$accuracy$log.p[[ref]][[test]][, -1, drop = FALSE];
acc.log.pBonf = mp$accuracy$log.pBonf[[ref]][[test]][, -1, drop = FALSE];
} else {
accZ = matrix(NA, nMods, 3);
acc.log.p = matrix(NA, nMods, 3);
acc.log.pBonf = matrix(NA, nMods, 3);
colnames(acc) = colnames(mp$accuracy$observed[[1]][[2]])[-1];
colnames(accZ) = colnames(mp$accuracy$Z[[1]][[2]])[-1];
colnames(acc.log.p) = colnames(mp$accuracy$log.p[[1]][[2]])[-1];
colnames(acc.log.pBonf) = colnames(mp$accuracy$log.pBonf[[1]][[2]])[-1];
}
# Table of results for this reference-test combination
tab = cbind(referenceSet = rep(setLabels[ref], nMods),
testSet = rep(setLabels[test], nMods),
moduleLabel = modules,
moduleSize = sizes,
mp$quality$observed[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$observed[[ref]][[test]][, -1, drop = FALSE],
acc,
mp$referenceSeparability$observed[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$observed[[ref]][[test]][, -1, drop = FALSE],
mp$quality$Z[[ref]][[test]][, -1, drop = FALSE],
mp$quality$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$quality$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$Z[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$preservation$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
accZ,
acc.log.p,
acc.log.pBonf,
mp$referenceSeparability$Z[[ref]][[test]][, -1, drop = FALSE],
mp$referenceSeparability$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$referenceSeparability$log.pBonf[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$Z[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$log.p[[ref]][[test]][, -1, drop = FALSE],
mp$testSeparability$log.pBonf[[ref]][[test]][, -1, drop = FALSE]

)
# Add the table to the main table.
if (is.null(summaryTable)) summaryTable = tab else summaryTable = rbind(summaryTable, tab);
}
# Save the table in csv format.
write.table(summaryTable, file ="../WGCNA_results/all_brain/result_terr_vs_flo_module_preservation.csv", row.names = FALSE, sep = ",", quote = FALSE)
```


```{r pres}
pres<- read.csv("../WGCNA_results/all_brain/result_terr_vs_flo_module_preservation.csv")

a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure_supp + scale_y_reverse()

b<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zsummary.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

c<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zdensity.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

d<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zconnectivity.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

e<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.separability.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp


f<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.propVarExplained.pres , fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

g<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanSignAwareKME.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

h<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanAdj.pres, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

i<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kIM, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

j<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kME, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

k<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.cor.kMEall, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp






z<- ggarrange(a,b,c,d,e,f,g,h,i,j,k,labels=c(LETTERS[1:11]))
ggsave(filename="../WGCNA_results/all_brain/figure_preservation_all.png",z, height=150,width=180, units="mm",bg="white", device="png")

ggsave(filename="../WGCNA_results/all_brain/figure_preservation_all.pdf",z, height=150,width=180, units="mm",bg="white", device="pdf")



a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.pres, fill=moduleLabel)) + geom_point(pch=21, size=2, stroke=0.2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure + scale_y_reverse() + labs(y="Median Rank")
ggsave(filename="../WGCNA_results/all_brain/figure_preservation_medianrank.pdf",a, height=40,width=35, units="mm",bg="white", device="pdf")
```

```{r quality}
a<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=medianRank.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + peri_figure_supp + scale_y_reverse()

b<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Zsummary.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

c<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.separability.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

d<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.propVarExplained.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

e<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanSignAwareKME.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp

f<- ggplot(pres[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey"),] , aes(x=moduleSize, y=Z.meanAdj.qual, fill=moduleLabel)) + geom_point(pch=21, size=2) + scale_fill_manual(values=pres$moduleLabel[which(pres$moduleLabel!="gold" & pres$moduleLabel!="grey")]) + theme(legend.position="none") + geom_text_repel(aes(label=moduleLabel), size=geom.text.size, segment.size=0.2) + geom_hline(yintercept=2, color="darkred",linewidth=0.2) + geom_hline(yintercept=10, color="darkred",linewidth=0.2, linetype="dashed") + peri_figure_supp


z<- ggarrange(a,b,c,d,e,f,labels=c(LETTERS[1:6]))
ggsave(filename="../WGCNA_results/HPG/figure_quality_all.png",z, height=150,width=180, units="mm",bg="white", device="png")

```



